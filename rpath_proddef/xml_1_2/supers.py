#!/usr/bin/env python

#
# Generated  by generateDS.py.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class stageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('labelSuffix', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, labelSuffix=None, name=None, valueOf_=''):
        self.labelSuffix = _cast(None, labelSuffix)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stageType.subclass:
            return stageType.subclass(*args_, **kwargs_)
        else:
            return stageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_labelSuffix(self): return self.labelSuffix
    def set_labelSuffix(self, labelSuffix): self.labelSuffix = labelSuffix
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='stageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='stageType'):
        outfile.write(' labelSuffix=%s' % (self.format_string(quote_attrib(self.labelSuffix).encode(ExternalEncoding), input_name='labelSuffix'), ))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='stageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.labelSuffix is not None:
            showIndent(outfile, level)
            outfile.write('labelSuffix = %s,\n' % (self.labelSuffix,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('labelSuffix'):
            self.labelSuffix = attrs.get('labelSuffix').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def getPromoteMaps(self):
        vals = self.get_promoteMaps()
        if vals is None:
            return []
        return vals.get_promoteMap()
# end class stageType


class stageListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('stage', 'stageType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, stage=None):
        if stage is None:
            self.stage = []
        else:
            self.stage = stage
    def factory(*args_, **kwargs_):
        if stageListType.subclass:
            return stageListType.subclass(*args_, **kwargs_)
        else:
            return stageListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stage(self): return self.stage
    def set_stage(self, stage): self.stage = stage
    def add_stage(self, value): self.stage.append(value)
    def insert_stage(self, index, value): self.stage[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='stageListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stageListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='stageListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='stageListType'):
        for stage_ in self.stage:
            stage_.export(outfile, level, namespace_, name_='stage')
    def hasContent_(self):
        if (
            self.stage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stageListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('stage=[\n')
        level += 1
        for stage in self.stage:
            showIndent(outfile, level)
            outfile.write('model_.stage(\n')
            stage.exportLiteral(outfile, level, name_='stage')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stage':
            obj_ = stageType.factory()
            obj_.build(child_)
            self.stage.append(obj_)
# end class stageListType


class searchPathType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('troveName', 'xsd:string', 0),
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('label', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, troveName=None, version=None, label=None, valueOf_=''):
        self.troveName = _cast(None, troveName)
        self.version = _cast(None, version)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if searchPathType.subclass:
            return searchPathType.subclass(*args_, **kwargs_)
        else:
            return searchPathType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_troveName(self): return self.troveName
    def set_troveName(self, troveName): self.troveName = troveName
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='searchPathType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='searchPathType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='searchPathType'):
        if self.troveName is not None:
            outfile.write(' troveName=%s' % (self.format_string(quote_attrib(self.troveName).encode(ExternalEncoding), input_name='troveName'), ))
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.label is not None:
            outfile.write(' label=%s' % (self.format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='searchPathType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='searchPathType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.troveName is not None:
            showIndent(outfile, level)
            outfile.write('troveName = %s,\n' % (self.troveName,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %s,\n' % (self.version,))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label = %s,\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('troveName'):
            self.troveName = attrs.get('troveName').value
        if attrs.get('version'):
            self.version = attrs.get('version').value
        if attrs.get('label'):
            self.label = attrs.get('label').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def getTroveTup(self, template=False):
        """
        Get a trovespec tuple for the search path or its template.

        @param template: If C{True}, use the template path; otherwise
            return the "pinned" path.
        @type  template: C{bool}
        @return: (name, version, flavor)
        """
        if template:
            return (self.troveName, self.label, None)
        else:
            version = self.label
            if self.version:
                version += '/' + self.version
            return (self.troveName, version, None)
# end class searchPathType


class searchPathListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('searchPath', 'searchPathType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, searchPath=None):
        if searchPath is None:
            self.searchPath = []
        else:
            self.searchPath = searchPath
    def factory(*args_, **kwargs_):
        if searchPathListType.subclass:
            return searchPathListType.subclass(*args_, **kwargs_)
        else:
            return searchPathListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_searchPath(self): return self.searchPath
    def set_searchPath(self, searchPath): self.searchPath = searchPath
    def add_searchPath(self, value): self.searchPath.append(value)
    def insert_searchPath(self, index, value): self.searchPath[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='searchPathListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='searchPathListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='searchPathListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='searchPathListType'):
        for searchPath_ in self.searchPath:
            searchPath_.export(outfile, level, namespace_, name_='searchPath')
    def hasContent_(self):
        if (
            self.searchPath
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='searchPathListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('searchPath=[\n')
        level += 1
        for searchPath in self.searchPath:
            showIndent(outfile, level)
            outfile.write('model_.searchPath(\n')
            searchPath.exportLiteral(outfile, level, name_='searchPath')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPath':
            obj_ = searchPathType.factory()
            obj_.build(child_)
            self.searchPath.append(obj_)
# end class searchPathListType


class factorySourceListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('factorySource', 'searchPathType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, factorySource=None):
        if factorySource is None:
            self.factorySource = []
        else:
            self.factorySource = factorySource
    def factory(*args_, **kwargs_):
        if factorySourceListType.subclass:
            return factorySourceListType.subclass(*args_, **kwargs_)
        else:
            return factorySourceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_factorySource(self): return self.factorySource
    def set_factorySource(self, factorySource): self.factorySource = factorySource
    def add_factorySource(self, value): self.factorySource.append(value)
    def insert_factorySource(self, index, value): self.factorySource[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='factorySourceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='factorySourceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='factorySourceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='factorySourceListType'):
        for factorySource_ in self.factorySource:
            factorySource_.export(outfile, level, namespace_, name_='factorySource')
    def hasContent_(self):
        if (
            self.factorySource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='factorySourceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('factorySource=[\n')
        level += 1
        for factorySource in self.factorySource:
            showIndent(outfile, level)
            outfile.write('model_.factorySource(\n')
            factorySource.exportLiteral(outfile, level, name_='factorySource')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySource':
            obj_ = searchPathType.factory()
            obj_.build(child_)
            self.factorySource.append(obj_)
# end class factorySourceListType


class amiImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('amiHugeDiskMountpoint', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, baseFileName=None, installLabelPath=None, amiHugeDiskMountpoint=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.amiHugeDiskMountpoint = _cast(None, amiHugeDiskMountpoint)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if amiImageType.subclass:
            return amiImageType.subclass(*args_, **kwargs_)
        else:
            return amiImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_amiHugeDiskMountpoint(self): return self.amiHugeDiskMountpoint
    def set_amiHugeDiskMountpoint(self, amiHugeDiskMountpoint): self.amiHugeDiskMountpoint = amiHugeDiskMountpoint
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='amiImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='amiImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='amiImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.amiHugeDiskMountpoint is not None:
            outfile.write(' amiHugeDiskMountpoint=%s' % (self.format_string(quote_attrib(self.amiHugeDiskMountpoint).encode(ExternalEncoding), input_name='amiHugeDiskMountpoint'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='amiImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='amiImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.amiHugeDiskMountpoint is not None:
            showIndent(outfile, level)
            outfile.write('amiHugeDiskMountpoint = %s,\n' % (self.amiHugeDiskMountpoint,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('amiHugeDiskMountpoint'):
            self.amiHugeDiskMountpoint = attrs.get('amiHugeDiskMountpoint').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class amiImageType


class applianceIsoImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('maxIsoSize', 'xsd:positiveInteger', 0),
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('bugsUrl', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('anacondaCustomTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('betaNag', 'xsd:boolean', 0),
        MemberSpec_('mediaTemplateTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('anacondaTemplatesTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('showMediaCheck', 'xsd:boolean', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, maxIsoSize=None, autoResolve=None, bugsUrl=None, name=None, anacondaCustomTrove=None, betaNag=None, mediaTemplateTrove=None, installLabelPath=None, anacondaTemplatesTrove=None, baseFileName=None, showMediaCheck=None, valueOf_=''):
        self.maxIsoSize = _cast(int, maxIsoSize)
        self.autoResolve = _cast(bool, autoResolve)
        self.bugsUrl = _cast(None, bugsUrl)
        self.name = _cast(None, name)
        self.anacondaCustomTrove = _cast(None, anacondaCustomTrove)
        self.betaNag = _cast(bool, betaNag)
        self.mediaTemplateTrove = _cast(None, mediaTemplateTrove)
        self.installLabelPath = _cast(None, installLabelPath)
        self.anacondaTemplatesTrove = _cast(None, anacondaTemplatesTrove)
        self.baseFileName = _cast(None, baseFileName)
        self.showMediaCheck = _cast(bool, showMediaCheck)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if applianceIsoImageType.subclass:
            return applianceIsoImageType.subclass(*args_, **kwargs_)
        else:
            return applianceIsoImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxIsoSize(self): return self.maxIsoSize
    def set_maxIsoSize(self, maxIsoSize): self.maxIsoSize = maxIsoSize
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_bugsUrl(self): return self.bugsUrl
    def set_bugsUrl(self, bugsUrl): self.bugsUrl = bugsUrl
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_anacondaCustomTrove(self): return self.anacondaCustomTrove
    def set_anacondaCustomTrove(self, anacondaCustomTrove): self.anacondaCustomTrove = anacondaCustomTrove
    def get_betaNag(self): return self.betaNag
    def set_betaNag(self, betaNag): self.betaNag = betaNag
    def get_mediaTemplateTrove(self): return self.mediaTemplateTrove
    def set_mediaTemplateTrove(self, mediaTemplateTrove): self.mediaTemplateTrove = mediaTemplateTrove
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_anacondaTemplatesTrove(self): return self.anacondaTemplatesTrove
    def set_anacondaTemplatesTrove(self, anacondaTemplatesTrove): self.anacondaTemplatesTrove = anacondaTemplatesTrove
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_showMediaCheck(self): return self.showMediaCheck
    def set_showMediaCheck(self, showMediaCheck): self.showMediaCheck = showMediaCheck
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='applianceIsoImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='applianceIsoImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='applianceIsoImageType'):
        if self.maxIsoSize is not None:
            outfile.write(' maxIsoSize="%s"' % self.format_integer(self.maxIsoSize, input_name='maxIsoSize'))
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.bugsUrl is not None:
            outfile.write(' bugsUrl=%s' % (self.format_string(quote_attrib(self.bugsUrl).encode(ExternalEncoding), input_name='bugsUrl'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.anacondaCustomTrove is not None:
            outfile.write(' anacondaCustomTrove=%s' % (quote_attrib(self.anacondaCustomTrove), ))
        if self.betaNag is not None:
            outfile.write(' betaNag="%s"' % self.format_boolean(str_lower(str(self.betaNag)), input_name='betaNag'))
        if self.mediaTemplateTrove is not None:
            outfile.write(' mediaTemplateTrove=%s' % (quote_attrib(self.mediaTemplateTrove), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.anacondaTemplatesTrove is not None:
            outfile.write(' anacondaTemplatesTrove=%s' % (quote_attrib(self.anacondaTemplatesTrove), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.showMediaCheck is not None:
            outfile.write(' showMediaCheck="%s"' % self.format_boolean(str_lower(str(self.showMediaCheck)), input_name='showMediaCheck'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='applianceIsoImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='applianceIsoImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.maxIsoSize is not None:
            showIndent(outfile, level)
            outfile.write('maxIsoSize = %s,\n' % (self.maxIsoSize,))
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.bugsUrl is not None:
            showIndent(outfile, level)
            outfile.write('bugsUrl = %s,\n' % (self.bugsUrl,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.anacondaCustomTrove is not None:
            showIndent(outfile, level)
            outfile.write('anacondaCustomTrove = "%s",\n' % (self.anacondaCustomTrove,))
        if self.betaNag is not None:
            showIndent(outfile, level)
            outfile.write('betaNag = %s,\n' % (self.betaNag,))
        if self.mediaTemplateTrove is not None:
            showIndent(outfile, level)
            outfile.write('mediaTemplateTrove = "%s",\n' % (self.mediaTemplateTrove,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.anacondaTemplatesTrove is not None:
            showIndent(outfile, level)
            outfile.write('anacondaTemplatesTrove = "%s",\n' % (self.anacondaTemplatesTrove,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.showMediaCheck is not None:
            showIndent(outfile, level)
            outfile.write('showMediaCheck = %s,\n' % (self.showMediaCheck,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('maxIsoSize'):
            try:
                self.maxIsoSize = int(attrs.get('maxIsoSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (maxIsoSize): %s' % exp)
            if self.maxIsoSize <= 0:
                raise ValueError('Invalid PositiveInteger (maxIsoSize)')
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('bugsUrl'):
            self.bugsUrl = attrs.get('bugsUrl').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('anacondaCustomTrove'):
            self.anacondaCustomTrove = attrs.get('anacondaCustomTrove').value
        if attrs.get('betaNag'):
            if attrs.get('betaNag').value in ('true', '1'):
                self.betaNag = True
            elif attrs.get('betaNag').value in ('false', '0'):
                self.betaNag = False
            else:
                raise ValueError('Bad boolean attribute (betaNag)')
        if attrs.get('mediaTemplateTrove'):
            self.mediaTemplateTrove = attrs.get('mediaTemplateTrove').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('anacondaTemplatesTrove'):
            self.anacondaTemplatesTrove = attrs.get('anacondaTemplatesTrove').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('showMediaCheck'):
            if attrs.get('showMediaCheck').value in ('true', '1'):
                self.showMediaCheck = True
            elif attrs.get('showMediaCheck').value in ('false', '0'):
                self.showMediaCheck = False
            else:
                raise ValueError('Bad boolean attribute (showMediaCheck)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class applianceIsoImageType


class installableIsoImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('maxIsoSize', 'xsd:positiveInteger', 0),
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('bugsUrl', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('anacondaCustomTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('betaNag', 'xsd:boolean', 0),
        MemberSpec_('mediaTemplateTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('anacondaTemplatesTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('showMediaCheck', 'xsd:boolean', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, maxIsoSize=None, autoResolve=None, bugsUrl=None, name=None, anacondaCustomTrove=None, betaNag=None, mediaTemplateTrove=None, installLabelPath=None, anacondaTemplatesTrove=None, baseFileName=None, showMediaCheck=None, valueOf_=''):
        self.maxIsoSize = _cast(int, maxIsoSize)
        self.autoResolve = _cast(bool, autoResolve)
        self.bugsUrl = _cast(None, bugsUrl)
        self.name = _cast(None, name)
        self.anacondaCustomTrove = _cast(None, anacondaCustomTrove)
        self.betaNag = _cast(bool, betaNag)
        self.mediaTemplateTrove = _cast(None, mediaTemplateTrove)
        self.installLabelPath = _cast(None, installLabelPath)
        self.anacondaTemplatesTrove = _cast(None, anacondaTemplatesTrove)
        self.baseFileName = _cast(None, baseFileName)
        self.showMediaCheck = _cast(bool, showMediaCheck)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if installableIsoImageType.subclass:
            return installableIsoImageType.subclass(*args_, **kwargs_)
        else:
            return installableIsoImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxIsoSize(self): return self.maxIsoSize
    def set_maxIsoSize(self, maxIsoSize): self.maxIsoSize = maxIsoSize
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_bugsUrl(self): return self.bugsUrl
    def set_bugsUrl(self, bugsUrl): self.bugsUrl = bugsUrl
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_anacondaCustomTrove(self): return self.anacondaCustomTrove
    def set_anacondaCustomTrove(self, anacondaCustomTrove): self.anacondaCustomTrove = anacondaCustomTrove
    def get_betaNag(self): return self.betaNag
    def set_betaNag(self, betaNag): self.betaNag = betaNag
    def get_mediaTemplateTrove(self): return self.mediaTemplateTrove
    def set_mediaTemplateTrove(self, mediaTemplateTrove): self.mediaTemplateTrove = mediaTemplateTrove
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_anacondaTemplatesTrove(self): return self.anacondaTemplatesTrove
    def set_anacondaTemplatesTrove(self, anacondaTemplatesTrove): self.anacondaTemplatesTrove = anacondaTemplatesTrove
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_showMediaCheck(self): return self.showMediaCheck
    def set_showMediaCheck(self, showMediaCheck): self.showMediaCheck = showMediaCheck
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='installableIsoImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='installableIsoImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='installableIsoImageType'):
        if self.maxIsoSize is not None:
            outfile.write(' maxIsoSize="%s"' % self.format_integer(self.maxIsoSize, input_name='maxIsoSize'))
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.bugsUrl is not None:
            outfile.write(' bugsUrl=%s' % (self.format_string(quote_attrib(self.bugsUrl).encode(ExternalEncoding), input_name='bugsUrl'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.anacondaCustomTrove is not None:
            outfile.write(' anacondaCustomTrove=%s' % (quote_attrib(self.anacondaCustomTrove), ))
        if self.betaNag is not None:
            outfile.write(' betaNag="%s"' % self.format_boolean(str_lower(str(self.betaNag)), input_name='betaNag'))
        if self.mediaTemplateTrove is not None:
            outfile.write(' mediaTemplateTrove=%s' % (quote_attrib(self.mediaTemplateTrove), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.anacondaTemplatesTrove is not None:
            outfile.write(' anacondaTemplatesTrove=%s' % (quote_attrib(self.anacondaTemplatesTrove), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.showMediaCheck is not None:
            outfile.write(' showMediaCheck="%s"' % self.format_boolean(str_lower(str(self.showMediaCheck)), input_name='showMediaCheck'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='installableIsoImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='installableIsoImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.maxIsoSize is not None:
            showIndent(outfile, level)
            outfile.write('maxIsoSize = %s,\n' % (self.maxIsoSize,))
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.bugsUrl is not None:
            showIndent(outfile, level)
            outfile.write('bugsUrl = %s,\n' % (self.bugsUrl,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.anacondaCustomTrove is not None:
            showIndent(outfile, level)
            outfile.write('anacondaCustomTrove = "%s",\n' % (self.anacondaCustomTrove,))
        if self.betaNag is not None:
            showIndent(outfile, level)
            outfile.write('betaNag = %s,\n' % (self.betaNag,))
        if self.mediaTemplateTrove is not None:
            showIndent(outfile, level)
            outfile.write('mediaTemplateTrove = "%s",\n' % (self.mediaTemplateTrove,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.anacondaTemplatesTrove is not None:
            showIndent(outfile, level)
            outfile.write('anacondaTemplatesTrove = "%s",\n' % (self.anacondaTemplatesTrove,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.showMediaCheck is not None:
            showIndent(outfile, level)
            outfile.write('showMediaCheck = %s,\n' % (self.showMediaCheck,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('maxIsoSize'):
            try:
                self.maxIsoSize = int(attrs.get('maxIsoSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (maxIsoSize): %s' % exp)
            if self.maxIsoSize <= 0:
                raise ValueError('Invalid PositiveInteger (maxIsoSize)')
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('bugsUrl'):
            self.bugsUrl = attrs.get('bugsUrl').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('anacondaCustomTrove'):
            self.anacondaCustomTrove = attrs.get('anacondaCustomTrove').value
        if attrs.get('betaNag'):
            if attrs.get('betaNag').value in ('true', '1'):
                self.betaNag = True
            elif attrs.get('betaNag').value in ('false', '0'):
                self.betaNag = False
            else:
                raise ValueError('Bad boolean attribute (betaNag)')
        if attrs.get('mediaTemplateTrove'):
            self.mediaTemplateTrove = attrs.get('mediaTemplateTrove').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('anacondaTemplatesTrove'):
            self.anacondaTemplatesTrove = attrs.get('anacondaTemplatesTrove').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('showMediaCheck'):
            if attrs.get('showMediaCheck').value in ('true', '1'):
                self.showMediaCheck = True
            elif attrs.get('showMediaCheck').value in ('false', '0'):
                self.showMediaCheck = False
            else:
                raise ValueError('Bad boolean attribute (showMediaCheck)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class installableIsoImageType


class liveIsoImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('zisofs', 'xsd:boolean', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('unionfs', 'xsd:boolean', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, name=None, zisofs=None, baseFileName=None, unionfs=None, installLabelPath=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.name = _cast(None, name)
        self.zisofs = _cast(bool, zisofs)
        self.baseFileName = _cast(None, baseFileName)
        self.unionfs = _cast(bool, unionfs)
        self.installLabelPath = _cast(None, installLabelPath)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if liveIsoImageType.subclass:
            return liveIsoImageType.subclass(*args_, **kwargs_)
        else:
            return liveIsoImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_zisofs(self): return self.zisofs
    def set_zisofs(self, zisofs): self.zisofs = zisofs
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_unionfs(self): return self.unionfs
    def set_unionfs(self, unionfs): self.unionfs = unionfs
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='liveIsoImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='liveIsoImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='liveIsoImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.zisofs is not None:
            outfile.write(' zisofs="%s"' % self.format_boolean(str_lower(str(self.zisofs)), input_name='zisofs'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.unionfs is not None:
            outfile.write(' unionfs="%s"' % self.format_boolean(str_lower(str(self.unionfs)), input_name='unionfs'))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='liveIsoImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='liveIsoImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.zisofs is not None:
            showIndent(outfile, level)
            outfile.write('zisofs = %s,\n' % (self.zisofs,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.unionfs is not None:
            showIndent(outfile, level)
            outfile.write('unionfs = %s,\n' % (self.unionfs,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('zisofs'):
            if attrs.get('zisofs').value in ('true', '1'):
                self.zisofs = True
            elif attrs.get('zisofs').value in ('false', '0'):
                self.zisofs = False
            else:
                raise ValueError('Bad boolean attribute (zisofs)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('unionfs'):
            if attrs.get('unionfs').value in ('true', '1'):
                self.unionfs = True
            elif attrs.get('unionfs').value in ('false', '0'):
                self.unionfs = False
            else:
                raise ValueError('Bad boolean attribute (unionfs)')
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class liveIsoImageType


class netbootImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, baseFileName=None, installLabelPath=None, name=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if netbootImageType.subclass:
            return netbootImageType.subclass(*args_, **kwargs_)
        else:
            return netbootImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='netbootImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='netbootImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='netbootImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='netbootImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='netbootImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class netbootImageType


class rawFsImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, swapSize=None, baseFileName=None, installLabelPath=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.swapSize = _cast(int, swapSize)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if rawFsImageType.subclass:
            return rawFsImageType.subclass(*args_, **kwargs_)
        else:
            return rawFsImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='rawFsImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='rawFsImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='rawFsImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='rawFsImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rawFsImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class rawFsImageType


class rawHdImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, swapSize=None, baseFileName=None, installLabelPath=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.swapSize = _cast(int, swapSize)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if rawHdImageType.subclass:
            return rawHdImageType.subclass(*args_, **kwargs_)
        else:
            return rawHdImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='rawHdImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='rawHdImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='rawHdImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='rawHdImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rawHdImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class rawHdImageType


class tarballImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, baseFileName=None, installLabelPath=None, name=None, swapSize=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.name = _cast(None, name)
        self.swapSize = _cast(int, swapSize)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if tarballImageType.subclass:
            return tarballImageType.subclass(*args_, **kwargs_)
        else:
            return tarballImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='tarballImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='tarballImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='tarballImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='tarballImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tarballImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class tarballImageType


class updateIsoImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('mediaTemplateTrove', 'xsd:string', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, mediaTemplateTrove=None, baseFileName=None, valueOf_=''):
        self.mediaTemplateTrove = _cast(None, mediaTemplateTrove)
        self.baseFileName = _cast(None, baseFileName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if updateIsoImageType.subclass:
            return updateIsoImageType.subclass(*args_, **kwargs_)
        else:
            return updateIsoImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mediaTemplateTrove(self): return self.mediaTemplateTrove
    def set_mediaTemplateTrove(self, mediaTemplateTrove): self.mediaTemplateTrove = mediaTemplateTrove
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='updateIsoImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='updateIsoImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='updateIsoImageType'):
        if self.mediaTemplateTrove is not None:
            outfile.write(' mediaTemplateTrove=%s' % (self.format_string(quote_attrib(self.mediaTemplateTrove).encode(ExternalEncoding), input_name='mediaTemplateTrove'), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='updateIsoImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='updateIsoImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.mediaTemplateTrove is not None:
            showIndent(outfile, level)
            outfile.write('mediaTemplateTrove = %s,\n' % (self.mediaTemplateTrove,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('mediaTemplateTrove'):
            self.mediaTemplateTrove = attrs.get('mediaTemplateTrove').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class updateIsoImageType


class vhdImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('vhdDiskType', 'xsd:string', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, vhdDiskType=None, swapSize=None, baseFileName=None, installLabelPath=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.vhdDiskType = _cast(None, vhdDiskType)
        self.swapSize = _cast(int, swapSize)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if vhdImageType.subclass:
            return vhdImageType.subclass(*args_, **kwargs_)
        else:
            return vhdImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_vhdDiskType(self): return self.vhdDiskType
    def set_vhdDiskType(self, vhdDiskType): self.vhdDiskType = vhdDiskType
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='vhdImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='vhdImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='vhdImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.vhdDiskType is not None:
            outfile.write(' vhdDiskType=%s' % (self.format_string(quote_attrib(self.vhdDiskType).encode(ExternalEncoding), input_name='vhdDiskType'), ))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='vhdImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vhdImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.vhdDiskType is not None:
            showIndent(outfile, level)
            outfile.write('vhdDiskType = %s,\n' % (self.vhdDiskType,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('vhdDiskType'):
            self.vhdDiskType = attrs.get('vhdDiskType').value
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class vhdImageType


class virtualIronImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('vhdDiskType', 'xsd:string', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, vhdDiskType=None, swapSize=None, baseFileName=None, installLabelPath=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.vhdDiskType = _cast(None, vhdDiskType)
        self.swapSize = _cast(int, swapSize)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if virtualIronImageType.subclass:
            return virtualIronImageType.subclass(*args_, **kwargs_)
        else:
            return virtualIronImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_vhdDiskType(self): return self.vhdDiskType
    def set_vhdDiskType(self, vhdDiskType): self.vhdDiskType = vhdDiskType
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='virtualIronImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='virtualIronImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='virtualIronImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.vhdDiskType is not None:
            outfile.write(' vhdDiskType=%s' % (self.format_string(quote_attrib(self.vhdDiskType).encode(ExternalEncoding), input_name='vhdDiskType'), ))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='virtualIronImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='virtualIronImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.vhdDiskType is not None:
            showIndent(outfile, level)
            outfile.write('vhdDiskType = %s,\n' % (self.vhdDiskType,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('vhdDiskType'):
            self.vhdDiskType = attrs.get('vhdDiskType').value
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class virtualIronImageType


class vmwareEsxImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('natNetworking', 'xsd:boolean', 0),
        MemberSpec_('vmMemory', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, natNetworking=None, vmMemory=None, swapSize=None, installLabelPath=None, baseFileName=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.natNetworking = _cast(bool, natNetworking)
        self.vmMemory = _cast(int, vmMemory)
        self.swapSize = _cast(int, swapSize)
        self.installLabelPath = _cast(None, installLabelPath)
        self.baseFileName = _cast(None, baseFileName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if vmwareEsxImageType.subclass:
            return vmwareEsxImageType.subclass(*args_, **kwargs_)
        else:
            return vmwareEsxImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_natNetworking(self): return self.natNetworking
    def set_natNetworking(self, natNetworking): self.natNetworking = natNetworking
    def get_vmMemory(self): return self.vmMemory
    def set_vmMemory(self, vmMemory): self.vmMemory = vmMemory
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='vmwareEsxImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='vmwareEsxImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='vmwareEsxImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.natNetworking is not None:
            outfile.write(' natNetworking="%s"' % self.format_boolean(str_lower(str(self.natNetworking)), input_name='natNetworking'))
        if self.vmMemory is not None:
            outfile.write(' vmMemory="%s"' % self.format_integer(self.vmMemory, input_name='vmMemory'))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='vmwareEsxImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vmwareEsxImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.natNetworking is not None:
            showIndent(outfile, level)
            outfile.write('natNetworking = %s,\n' % (self.natNetworking,))
        if self.vmMemory is not None:
            showIndent(outfile, level)
            outfile.write('vmMemory = %s,\n' % (self.vmMemory,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('natNetworking'):
            if attrs.get('natNetworking').value in ('true', '1'):
                self.natNetworking = True
            elif attrs.get('natNetworking').value in ('false', '0'):
                self.natNetworking = False
            else:
                raise ValueError('Bad boolean attribute (natNetworking)')
        if attrs.get('vmMemory'):
            try:
                self.vmMemory = int(attrs.get('vmMemory').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (vmMemory): %s' % exp)
            if self.vmMemory < 0:
                raise ValueError('Invalid NonNegativeInteger (vmMemory)')
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class vmwareEsxImageType


class vmwareImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('natNetworking', 'xsd:boolean', 0),
        MemberSpec_('vmMemory', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('diskAdapter', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('vmSnapshots', 'xsd:boolean', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, natNetworking=None, vmMemory=None, swapSize=None, diskAdapter=None, installLabelPath=None, baseFileName=None, vmSnapshots=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.natNetworking = _cast(bool, natNetworking)
        self.vmMemory = _cast(int, vmMemory)
        self.swapSize = _cast(int, swapSize)
        self.diskAdapter = _cast(None, diskAdapter)
        self.installLabelPath = _cast(None, installLabelPath)
        self.baseFileName = _cast(None, baseFileName)
        self.vmSnapshots = _cast(bool, vmSnapshots)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if vmwareImageType.subclass:
            return vmwareImageType.subclass(*args_, **kwargs_)
        else:
            return vmwareImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_natNetworking(self): return self.natNetworking
    def set_natNetworking(self, natNetworking): self.natNetworking = natNetworking
    def get_vmMemory(self): return self.vmMemory
    def set_vmMemory(self, vmMemory): self.vmMemory = vmMemory
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_diskAdapter(self): return self.diskAdapter
    def set_diskAdapter(self, diskAdapter): self.diskAdapter = diskAdapter
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_vmSnapshots(self): return self.vmSnapshots
    def set_vmSnapshots(self, vmSnapshots): self.vmSnapshots = vmSnapshots
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='vmwareImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='vmwareImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='vmwareImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.natNetworking is not None:
            outfile.write(' natNetworking="%s"' % self.format_boolean(str_lower(str(self.natNetworking)), input_name='natNetworking'))
        if self.vmMemory is not None:
            outfile.write(' vmMemory="%s"' % self.format_integer(self.vmMemory, input_name='vmMemory'))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.diskAdapter is not None:
            outfile.write(' diskAdapter=%s' % (self.format_string(quote_attrib(self.diskAdapter).encode(ExternalEncoding), input_name='diskAdapter'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.vmSnapshots is not None:
            outfile.write(' vmSnapshots="%s"' % self.format_boolean(str_lower(str(self.vmSnapshots)), input_name='vmSnapshots'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='vmwareImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vmwareImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.natNetworking is not None:
            showIndent(outfile, level)
            outfile.write('natNetworking = %s,\n' % (self.natNetworking,))
        if self.vmMemory is not None:
            showIndent(outfile, level)
            outfile.write('vmMemory = %s,\n' % (self.vmMemory,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.diskAdapter is not None:
            showIndent(outfile, level)
            outfile.write('diskAdapter = %s,\n' % (self.diskAdapter,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.vmSnapshots is not None:
            showIndent(outfile, level)
            outfile.write('vmSnapshots = %s,\n' % (self.vmSnapshots,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('natNetworking'):
            if attrs.get('natNetworking').value in ('true', '1'):
                self.natNetworking = True
            elif attrs.get('natNetworking').value in ('false', '0'):
                self.natNetworking = False
            else:
                raise ValueError('Bad boolean attribute (natNetworking)')
        if attrs.get('vmMemory'):
            try:
                self.vmMemory = int(attrs.get('vmMemory').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (vmMemory): %s' % exp)
            if self.vmMemory < 0:
                raise ValueError('Invalid NonNegativeInteger (vmMemory)')
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('diskAdapter'):
            self.diskAdapter = attrs.get('diskAdapter').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('vmSnapshots'):
            if attrs.get('vmSnapshots').value in ('true', '1'):
                self.vmSnapshots = True
            elif attrs.get('vmSnapshots').value in ('false', '0'):
                self.vmSnapshots = False
            else:
                raise ValueError('Bad boolean attribute (vmSnapshots)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class vmwareImageType


class xenOvaImageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('vmMemory', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, freespace=None, name=None, vmMemory=None, swapSize=None, baseFileName=None, installLabelPath=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.vmMemory = _cast(int, vmMemory)
        self.swapSize = _cast(int, swapSize)
        self.baseFileName = _cast(None, baseFileName)
        self.installLabelPath = _cast(None, installLabelPath)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if xenOvaImageType.subclass:
            return xenOvaImageType.subclass(*args_, **kwargs_)
        else:
            return xenOvaImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_vmMemory(self): return self.vmMemory
    def set_vmMemory(self, vmMemory): self.vmMemory = vmMemory
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='xenOvaImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='xenOvaImageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='xenOvaImageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.vmMemory is not None:
            outfile.write(' vmMemory="%s"' % self.format_integer(self.vmMemory, input_name='vmMemory'))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='xenOvaImageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='xenOvaImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %s,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.vmMemory is not None:
            showIndent(outfile, level)
            outfile.write('vmMemory = %s,\n' % (self.vmMemory,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %s,\n' % (self.swapSize,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = %s,\n' % (self.baseFileName,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = %s,\n' % (self.installLabelPath,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('vmMemory'):
            try:
                self.vmMemory = int(attrs.get('vmMemory').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (vmMemory): %s' % exp)
            if self.vmMemory < 0:
                raise ValueError('Invalid NonNegativeInteger (vmMemory)')
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class xenOvaImageType


class buildDefinitionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('build_', 'buildType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, build_=None):
        if build_ is None:
            self.build_ = []
        else:
            self.build_ = build_
    def factory(*args_, **kwargs_):
        if buildDefinitionType.subclass:
            return buildDefinitionType.subclass(*args_, **kwargs_)
        else:
            return buildDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_build(self): return self.build_
    def set_build(self, build_): self.build_ = build_
    def add_build(self, value): self.build_.append(value)
    def insert_build(self, index, value): self.build_[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='buildDefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='buildDefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='buildDefinitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='buildDefinitionType'):
        for build_ in self.build_:
            build_.export(outfile, level, namespace_, name_='build')
    def hasContent_(self):
        if (
            self.build_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='buildDefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('build=[\n')
        level += 1
        for build in self.build:
            showIndent(outfile, level)
            outfile.write('model_.build(\n')
            build.exportLiteral(outfile, level, name_='build')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'build':
            obj_ = buildType.factory()
            obj_.build(child_)
            self.build_.append(obj_)
# end class buildDefinitionType


class buildType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('baseFlavor', 'rpd:flavorStringType', 0),
        MemberSpec_('flavor', 'rpd:flavorStringType', 0),
        MemberSpec_('architectureRef', 'xsd:string', 0),
        MemberSpec_('imageTemplateRef', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('amiImage', 'amiImageType', 0),
        MemberSpec_('applianceIsoImage', 'applianceIsoImageType', 0),
        MemberSpec_('installableIsoImage', 'installableIsoImageType', 0),
        MemberSpec_('liveIsoImage', 'liveIsoImageType', 0),
        MemberSpec_('netbootImage', 'netbootImageType', 0),
        MemberSpec_('rawFsImage', 'rawFsImageType', 0),
        MemberSpec_('rawHdImage', 'rawHdImageType', 0),
        MemberSpec_('tarballImage', 'tarballImageType', 0),
        MemberSpec_('updateIsoImage', 'updateIsoImageType', 0),
        MemberSpec_('vhdImage', 'vhdImageType', 0),
        MemberSpec_('virtualIronImage', 'virtualIronImageType', 0),
        MemberSpec_('vmwareImage', 'vmwareImageType', 0),
        MemberSpec_('vmwareEsxImage', 'vmwareEsxImageType', 0),
        MemberSpec_('xenOvaImage', 'xenOvaImageType', 0),
        MemberSpec_('stage', 'stage', 1),
        MemberSpec_('imageGroup', ['troveSpecType', 'xsd:string'], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, baseFlavor=None, flavor=None, architectureRef=None, imageTemplateRef=None, name=None, amiImage=None, applianceIsoImage=None, installableIsoImage=None, liveIsoImage=None, netbootImage=None, rawFsImage=None, rawHdImage=None, tarballImage=None, updateIsoImage=None, vhdImage=None, virtualIronImage=None, vmwareImage=None, vmwareEsxImage=None, xenOvaImage=None, stage=None, imageGroup=None):
        self.baseFlavor = _cast(None, baseFlavor)
        self.flavor = _cast(None, flavor)
        self.architectureRef = _cast(None, architectureRef)
        self.imageTemplateRef = _cast(None, imageTemplateRef)
        self.name = _cast(None, name)
        self.amiImage = amiImage
        self.applianceIsoImage = applianceIsoImage
        self.installableIsoImage = installableIsoImage
        self.liveIsoImage = liveIsoImage
        self.netbootImage = netbootImage
        self.rawFsImage = rawFsImage
        self.rawHdImage = rawHdImage
        self.tarballImage = tarballImage
        self.updateIsoImage = updateIsoImage
        self.vhdImage = vhdImage
        self.virtualIronImage = virtualIronImage
        self.vmwareImage = vmwareImage
        self.vmwareEsxImage = vmwareEsxImage
        self.xenOvaImage = xenOvaImage
        if stage is None:
            self.stage = []
        else:
            self.stage = stage
        self.imageGroup = imageGroup
    def factory(*args_, **kwargs_):
        if buildType.subclass:
            return buildType.subclass(*args_, **kwargs_)
        else:
            return buildType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amiImage(self): return self.amiImage
    def set_amiImage(self, amiImage): self.amiImage = amiImage
    def get_applianceIsoImage(self): return self.applianceIsoImage
    def set_applianceIsoImage(self, applianceIsoImage): self.applianceIsoImage = applianceIsoImage
    def get_installableIsoImage(self): return self.installableIsoImage
    def set_installableIsoImage(self, installableIsoImage): self.installableIsoImage = installableIsoImage
    def get_liveIsoImage(self): return self.liveIsoImage
    def set_liveIsoImage(self, liveIsoImage): self.liveIsoImage = liveIsoImage
    def get_netbootImage(self): return self.netbootImage
    def set_netbootImage(self, netbootImage): self.netbootImage = netbootImage
    def get_rawFsImage(self): return self.rawFsImage
    def set_rawFsImage(self, rawFsImage): self.rawFsImage = rawFsImage
    def get_rawHdImage(self): return self.rawHdImage
    def set_rawHdImage(self, rawHdImage): self.rawHdImage = rawHdImage
    def get_tarballImage(self): return self.tarballImage
    def set_tarballImage(self, tarballImage): self.tarballImage = tarballImage
    def get_updateIsoImage(self): return self.updateIsoImage
    def set_updateIsoImage(self, updateIsoImage): self.updateIsoImage = updateIsoImage
    def get_vhdImage(self): return self.vhdImage
    def set_vhdImage(self, vhdImage): self.vhdImage = vhdImage
    def get_virtualIronImage(self): return self.virtualIronImage
    def set_virtualIronImage(self, virtualIronImage): self.virtualIronImage = virtualIronImage
    def get_vmwareImage(self): return self.vmwareImage
    def set_vmwareImage(self, vmwareImage): self.vmwareImage = vmwareImage
    def get_vmwareEsxImage(self): return self.vmwareEsxImage
    def set_vmwareEsxImage(self, vmwareEsxImage): self.vmwareEsxImage = vmwareEsxImage
    def get_xenOvaImage(self): return self.xenOvaImage
    def set_xenOvaImage(self, xenOvaImage): self.xenOvaImage = xenOvaImage
    def get_stage(self): return self.stage
    def set_stage(self, stage): self.stage = stage
    def add_stage(self, value): self.stage.append(value)
    def insert_stage(self, index, value): self.stage[index] = value
    def get_imageGroup(self): return self.imageGroup
    def set_imageGroup(self, imageGroup): self.imageGroup = imageGroup
    def validate_imageGroup(self, value):
        # validate type imageGroup
        pass
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def get_flavor(self): return self.flavor
    def set_flavor(self, flavor): self.flavor = flavor
    def get_architectureRef(self): return self.architectureRef
    def set_architectureRef(self, architectureRef): self.architectureRef = architectureRef
    def get_imageTemplateRef(self): return self.imageTemplateRef
    def set_imageTemplateRef(self, imageTemplateRef): self.imageTemplateRef = imageTemplateRef
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='rpd:', name_='buildType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='buildType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='buildType'):
        if self.baseFlavor is not None:
            outfile.write(' baseFlavor=%s' % (quote_attrib(self.baseFlavor), ))
        if self.flavor is not None:
            outfile.write(' flavor=%s' % (quote_attrib(self.flavor), ))
        if self.architectureRef is not None:
            outfile.write(' architectureRef=%s' % (self.format_string(quote_attrib(self.architectureRef).encode(ExternalEncoding), input_name='architectureRef'), ))
        if self.imageTemplateRef is not None:
            outfile.write(' imageTemplateRef=%s' % (self.format_string(quote_attrib(self.imageTemplateRef).encode(ExternalEncoding), input_name='imageTemplateRef'), ))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='buildType'):
        if self.amiImage:
            self.amiImage.export(outfile, level, namespace_, name_='amiImage', )
        if self.applianceIsoImage:
            self.applianceIsoImage.export(outfile, level, namespace_, name_='applianceIsoImage', )
        if self.installableIsoImage:
            self.installableIsoImage.export(outfile, level, namespace_, name_='installableIsoImage', )
        if self.liveIsoImage:
            self.liveIsoImage.export(outfile, level, namespace_, name_='liveIsoImage', )
        if self.netbootImage:
            self.netbootImage.export(outfile, level, namespace_, name_='netbootImage', )
        if self.rawFsImage:
            self.rawFsImage.export(outfile, level, namespace_, name_='rawFsImage', )
        if self.rawHdImage:
            self.rawHdImage.export(outfile, level, namespace_, name_='rawHdImage', )
        if self.tarballImage:
            self.tarballImage.export(outfile, level, namespace_, name_='tarballImage', )
        if self.updateIsoImage:
            self.updateIsoImage.export(outfile, level, namespace_, name_='updateIsoImage', )
        if self.vhdImage:
            self.vhdImage.export(outfile, level, namespace_, name_='vhdImage', )
        if self.virtualIronImage:
            self.virtualIronImage.export(outfile, level, namespace_, name_='virtualIronImage', )
        if self.vmwareImage:
            self.vmwareImage.export(outfile, level, namespace_, name_='vmwareImage', )
        if self.vmwareEsxImage:
            self.vmwareEsxImage.export(outfile, level, namespace_, name_='vmwareEsxImage', )
        if self.xenOvaImage:
            self.xenOvaImage.export(outfile, level, namespace_, name_='xenOvaImage', )
        for stage_ in self.stage:
            stage_.export(outfile, level, namespace_, name_='stage')
        if self.imageGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%simageGroup>%s</%simageGroup>\n' % (namespace_, self.format_string(quote_xml(self.imageGroup).encode(ExternalEncoding), input_name='imageGroup'), namespace_))
    def hasContent_(self):
        if (
            self.amiImage is not None or
            self.applianceIsoImage is not None or
            self.installableIsoImage is not None or
            self.liveIsoImage is not None or
            self.netbootImage is not None or
            self.rawFsImage is not None or
            self.rawHdImage is not None or
            self.tarballImage is not None or
            self.updateIsoImage is not None or
            self.vhdImage is not None or
            self.virtualIronImage is not None or
            self.vmwareImage is not None or
            self.vmwareEsxImage is not None or
            self.xenOvaImage is not None or
            self.stage or
            self.imageGroup is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='buildType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('baseFlavor = "%s",\n' % (self.baseFlavor,))
        if self.flavor is not None:
            showIndent(outfile, level)
            outfile.write('flavor = "%s",\n' % (self.flavor,))
        if self.architectureRef is not None:
            showIndent(outfile, level)
            outfile.write('architectureRef = %s,\n' % (self.architectureRef,))
        if self.imageTemplateRef is not None:
            showIndent(outfile, level)
            outfile.write('imageTemplateRef = %s,\n' % (self.imageTemplateRef,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.amiImage:
            showIndent(outfile, level)
            outfile.write('amiImage=model_.amiImageType(\n')
            self.amiImage.exportLiteral(outfile, level, name_='amiImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.applianceIsoImage:
            showIndent(outfile, level)
            outfile.write('applianceIsoImage=model_.applianceIsoImageType(\n')
            self.applianceIsoImage.exportLiteral(outfile, level, name_='applianceIsoImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.installableIsoImage:
            showIndent(outfile, level)
            outfile.write('installableIsoImage=model_.installableIsoImageType(\n')
            self.installableIsoImage.exportLiteral(outfile, level, name_='installableIsoImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.liveIsoImage:
            showIndent(outfile, level)
            outfile.write('liveIsoImage=model_.liveIsoImageType(\n')
            self.liveIsoImage.exportLiteral(outfile, level, name_='liveIsoImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.netbootImage:
            showIndent(outfile, level)
            outfile.write('netbootImage=model_.netbootImageType(\n')
            self.netbootImage.exportLiteral(outfile, level, name_='netbootImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rawFsImage:
            showIndent(outfile, level)
            outfile.write('rawFsImage=model_.rawFsImageType(\n')
            self.rawFsImage.exportLiteral(outfile, level, name_='rawFsImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rawHdImage:
            showIndent(outfile, level)
            outfile.write('rawHdImage=model_.rawHdImageType(\n')
            self.rawHdImage.exportLiteral(outfile, level, name_='rawHdImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tarballImage:
            showIndent(outfile, level)
            outfile.write('tarballImage=model_.tarballImageType(\n')
            self.tarballImage.exportLiteral(outfile, level, name_='tarballImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.updateIsoImage:
            showIndent(outfile, level)
            outfile.write('updateIsoImage=model_.updateIsoImageType(\n')
            self.updateIsoImage.exportLiteral(outfile, level, name_='updateIsoImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vhdImage:
            showIndent(outfile, level)
            outfile.write('vhdImage=model_.vhdImageType(\n')
            self.vhdImage.exportLiteral(outfile, level, name_='vhdImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.virtualIronImage:
            showIndent(outfile, level)
            outfile.write('virtualIronImage=model_.virtualIronImageType(\n')
            self.virtualIronImage.exportLiteral(outfile, level, name_='virtualIronImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vmwareImage:
            showIndent(outfile, level)
            outfile.write('vmwareImage=model_.vmwareImageType(\n')
            self.vmwareImage.exportLiteral(outfile, level, name_='vmwareImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vmwareEsxImage:
            showIndent(outfile, level)
            outfile.write('vmwareEsxImage=model_.vmwareEsxImageType(\n')
            self.vmwareEsxImage.exportLiteral(outfile, level, name_='vmwareEsxImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.xenOvaImage:
            showIndent(outfile, level)
            outfile.write('xenOvaImage=model_.xenOvaImageType(\n')
            self.xenOvaImage.exportLiteral(outfile, level, name_='xenOvaImage')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stage=[\n')
        level += 1
        for stage in self.stage:
            showIndent(outfile, level)
            outfile.write('model_.stage(\n')
            stage.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('imageGroup=%s,\n' % quote_python(self.imageGroup).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('baseFlavor'):
            self.baseFlavor = attrs.get('baseFlavor').value
        if attrs.get('flavor'):
            self.flavor = attrs.get('flavor').value
        if attrs.get('architectureRef'):
            self.architectureRef = attrs.get('architectureRef').value
        if attrs.get('imageTemplateRef'):
            self.imageTemplateRef = attrs.get('imageTemplateRef').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'amiImage':
            obj_ = amiImageType.factory()
            obj_.build(child_)
            self.set_amiImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'applianceIsoImage':
            obj_ = applianceIsoImageType.factory()
            obj_.build(child_)
            self.set_applianceIsoImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'installableIsoImage':
            obj_ = installableIsoImageType.factory()
            obj_.build(child_)
            self.set_installableIsoImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'liveIsoImage':
            obj_ = liveIsoImageType.factory()
            obj_.build(child_)
            self.set_liveIsoImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'netbootImage':
            obj_ = netbootImageType.factory()
            obj_.build(child_)
            self.set_netbootImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rawFsImage':
            obj_ = rawFsImageType.factory()
            obj_.build(child_)
            self.set_rawFsImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rawHdImage':
            obj_ = rawHdImageType.factory()
            obj_.build(child_)
            self.set_rawHdImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'tarballImage':
            obj_ = tarballImageType.factory()
            obj_.build(child_)
            self.set_tarballImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'updateIsoImage':
            obj_ = updateIsoImageType.factory()
            obj_.build(child_)
            self.set_updateIsoImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'vhdImage':
            obj_ = vhdImageType.factory()
            obj_.build(child_)
            self.set_vhdImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'virtualIronImage':
            obj_ = virtualIronImageType.factory()
            obj_.build(child_)
            self.set_virtualIronImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'vmwareImage':
            obj_ = vmwareImageType.factory()
            obj_.build(child_)
            self.set_vmwareImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'vmwareEsxImage':
            obj_ = vmwareEsxImageType.factory()
            obj_.build(child_)
            self.set_vmwareEsxImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'xenOvaImage':
            obj_ = xenOvaImageType.factory()
            obj_.build(child_)
            self.set_xenOvaImage(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stage':
            obj_ = stage.factory()
            obj_.build(child_)
            self.stage.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageGroup':
            imageGroup_ = ''
            for text__content_ in child_.childNodes:
                imageGroup_ += text__content_.nodeValue
            self.imageGroup = imageGroup_
            self.validate_imageGroup(self.imageGroup)    # validate type imageGroup

    def getBuildStages(self):
        return [ x.get_ref() for x in self.get_stage() ]

    def getBuildImageGroup(self):
        val = self.get_imageGroup()
        if val is None:
            return self.parentImageGroup
        return val

    def getBuildSourceGroup(self):
        val = self.get_sourceGroup()
        if val is None:
            return self.parentSourceGroup
        return val

    def getBuildBaseFlavor(self):
        return self.buildFlavor

    def getBuildImage(self):
        fields = self.containerTemplateFields.copy()
        if self.image:
            fields.update(self.image.getFields())
        return imageType.subclass.factory(**fields)

    getBuildName = get_name
# end class buildType


class stage(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ref', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, ref=None, valueOf_=''):
        self.ref = _cast(None, ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stage.subclass:
            return stage.subclass(*args_, **kwargs_)
        else:
            return stage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='stage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stage')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='stage'):
        outfile.write(' ref=%s' % (self.format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='stage'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.ref is not None:
            showIndent(outfile, level)
            outfile.write('ref = %s,\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('ref'):
            self.ref = attrs.get('ref').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class stage


class platformDefinitionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('baseFlavor', ['flavorStringType', 'xsd:string'], 0),
        MemberSpec_('searchPaths', 'searchPathListType', 0),
        MemberSpec_('factorySources', 'factorySourceListType', 0),
        MemberSpec_('architectures', 'architecturesType', 0),
        MemberSpec_('imageTemplates', 'imageTemplatesType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, version=None, baseFlavor=None, searchPaths=None, factorySources=None, architectures=None, imageTemplates=None):
        self.version = _cast(None, version)
        self.baseFlavor = baseFlavor
        self.searchPaths = searchPaths
        self.factorySources = factorySources
        self.architectures = architectures
        self.imageTemplates = imageTemplates
    def factory(*args_, **kwargs_):
        if platformDefinitionType.subclass:
            return platformDefinitionType.subclass(*args_, **kwargs_)
        else:
            return platformDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def validate_baseFlavor(self, value):
        # validate type baseFlavor
        pass
    def get_searchPaths(self): return self.searchPaths
    def set_searchPaths(self, searchPaths): self.searchPaths = searchPaths
    def get_factorySources(self): return self.factorySources
    def set_factorySources(self, factorySources): self.factorySources = factorySources
    def get_architectures(self): return self.architectures
    def set_architectures(self, architectures): self.architectures = architectures
    def get_imageTemplates(self): return self.imageTemplates
    def set_imageTemplates(self, imageTemplates): self.imageTemplates = imageTemplates
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='rpd:', name_='platformDefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='platformDefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='platformDefinitionType'):
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='platformDefinitionType'):
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseFlavor>%s</%sbaseFlavor>\n' % (namespace_, self.format_string(quote_xml(self.baseFlavor).encode(ExternalEncoding), input_name='baseFlavor'), namespace_))
        if self.searchPaths:
            self.searchPaths.export(outfile, level, namespace_, name_='searchPaths')
        if self.factorySources:
            self.factorySources.export(outfile, level, namespace_, name_='factorySources')
        if self.architectures:
            self.architectures.export(outfile, level, namespace_, name_='architectures')
        if self.imageTemplates:
            self.imageTemplates.export(outfile, level, namespace_, name_='imageTemplates')
    def hasContent_(self):
        if (
            self.baseFlavor is not None or
            self.searchPaths is not None or
            self.factorySources is not None or
            self.architectures is not None or
            self.imageTemplates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='platformDefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %s,\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('baseFlavor=%s,\n' % quote_python(self.baseFlavor).encode(ExternalEncoding))
        if self.searchPaths:
            showIndent(outfile, level)
            outfile.write('searchPaths=model_.searchPathListType(\n')
            self.searchPaths.exportLiteral(outfile, level, name_='searchPaths')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.factorySources:
            showIndent(outfile, level)
            outfile.write('factorySources=model_.factorySourceListType(\n')
            self.factorySources.exportLiteral(outfile, level, name_='factorySources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.architectures:
            showIndent(outfile, level)
            outfile.write('architectures=model_.architecturesType(\n')
            self.architectures.exportLiteral(outfile, level, name_='architectures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imageTemplates:
            showIndent(outfile, level)
            outfile.write('imageTemplates=model_.imageTemplatesType(\n')
            self.imageTemplates.exportLiteral(outfile, level, name_='imageTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseFlavor':
            baseFlavor_ = ''
            for text__content_ in child_.childNodes:
                baseFlavor_ += text__content_.nodeValue
            self.baseFlavor = baseFlavor_
            self.validate_baseFlavor(self.baseFlavor)    # validate type baseFlavor
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPaths':
            obj_ = searchPathListType.factory()
            obj_.build(child_)
            self.set_searchPaths(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySources':
            obj_ = factorySourceListType.factory()
            obj_.build(child_)
            self.set_factorySources(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architectures':
            obj_ = architecturesType.factory()
            obj_.build(child_)
            self.set_architectures(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageTemplates':
            obj_ = imageTemplatesType.factory()
            obj_.build(child_)
            self.set_imageTemplates(obj_)
# end class platformDefinitionType


class platformType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('sourceTrove', 'xsd:string', 0),
        MemberSpec_('useLatest', 'xsd:boolean', 0),
        MemberSpec_('baseFlavor', ['flavorStringType', 'xsd:string'], 0),
        MemberSpec_('searchPaths', 'searchPathListType', 0),
        MemberSpec_('factorySources', 'factorySourceListType', 0),
        MemberSpec_('architectures', 'architecturesType', 0),
        MemberSpec_('imageTemplates', 'imageTemplatesType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, sourceTrove=None, useLatest=None, baseFlavor=None, searchPaths=None, factorySources=None, architectures=None, imageTemplates=None):
        self.sourceTrove = _cast(None, sourceTrove)
        self.useLatest = _cast(bool, useLatest)
        self.baseFlavor = baseFlavor
        self.searchPaths = searchPaths
        self.factorySources = factorySources
        self.architectures = architectures
        self.imageTemplates = imageTemplates
    def factory(*args_, **kwargs_):
        if platformType.subclass:
            return platformType.subclass(*args_, **kwargs_)
        else:
            return platformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def validate_baseFlavor(self, value):
        # validate type baseFlavor
        pass
    def get_searchPaths(self): return self.searchPaths
    def set_searchPaths(self, searchPaths): self.searchPaths = searchPaths
    def get_factorySources(self): return self.factorySources
    def set_factorySources(self, factorySources): self.factorySources = factorySources
    def get_architectures(self): return self.architectures
    def set_architectures(self, architectures): self.architectures = architectures
    def get_imageTemplates(self): return self.imageTemplates
    def set_imageTemplates(self, imageTemplates): self.imageTemplates = imageTemplates
    def get_sourceTrove(self): return self.sourceTrove
    def set_sourceTrove(self, sourceTrove): self.sourceTrove = sourceTrove
    def get_useLatest(self): return self.useLatest
    def set_useLatest(self, useLatest): self.useLatest = useLatest
    def export(self, outfile, level, namespace_='rpd:', name_='platformType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='platformType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='platformType'):
        if self.sourceTrove is not None:
            outfile.write(' sourceTrove=%s' % (self.format_string(quote_attrib(self.sourceTrove).encode(ExternalEncoding), input_name='sourceTrove'), ))
        if self.useLatest is not None:
            outfile.write(' useLatest="%s"' % self.format_boolean(str_lower(str(self.useLatest)), input_name='useLatest'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='platformType'):
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseFlavor>%s</%sbaseFlavor>\n' % (namespace_, self.format_string(quote_xml(self.baseFlavor).encode(ExternalEncoding), input_name='baseFlavor'), namespace_))
        if self.searchPaths:
            self.searchPaths.export(outfile, level, namespace_, name_='searchPaths')
        if self.factorySources:
            self.factorySources.export(outfile, level, namespace_, name_='factorySources')
        if self.architectures:
            self.architectures.export(outfile, level, namespace_, name_='architectures')
        if self.imageTemplates:
            self.imageTemplates.export(outfile, level, namespace_, name_='imageTemplates')
    def hasContent_(self):
        if (
            self.baseFlavor is not None or
            self.searchPaths is not None or
            self.factorySources is not None or
            self.architectures is not None or
            self.imageTemplates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='platformType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.sourceTrove is not None:
            showIndent(outfile, level)
            outfile.write('sourceTrove = %s,\n' % (self.sourceTrove,))
        if self.useLatest is not None:
            showIndent(outfile, level)
            outfile.write('useLatest = %s,\n' % (self.useLatest,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('baseFlavor=%s,\n' % quote_python(self.baseFlavor).encode(ExternalEncoding))
        if self.searchPaths:
            showIndent(outfile, level)
            outfile.write('searchPaths=model_.searchPathListType(\n')
            self.searchPaths.exportLiteral(outfile, level, name_='searchPaths')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.factorySources:
            showIndent(outfile, level)
            outfile.write('factorySources=model_.factorySourceListType(\n')
            self.factorySources.exportLiteral(outfile, level, name_='factorySources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.architectures:
            showIndent(outfile, level)
            outfile.write('architectures=model_.architecturesType(\n')
            self.architectures.exportLiteral(outfile, level, name_='architectures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imageTemplates:
            showIndent(outfile, level)
            outfile.write('imageTemplates=model_.imageTemplatesType(\n')
            self.imageTemplates.exportLiteral(outfile, level, name_='imageTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('sourceTrove'):
            self.sourceTrove = attrs.get('sourceTrove').value
        if attrs.get('useLatest'):
            if attrs.get('useLatest').value in ('true', '1'):
                self.useLatest = True
            elif attrs.get('useLatest').value in ('false', '0'):
                self.useLatest = False
            else:
                raise ValueError('Bad boolean attribute (useLatest)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseFlavor':
            baseFlavor_ = ''
            for text__content_ in child_.childNodes:
                baseFlavor_ += text__content_.nodeValue
            self.baseFlavor = baseFlavor_
            self.validate_baseFlavor(self.baseFlavor)    # validate type baseFlavor
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPaths':
            obj_ = searchPathListType.factory()
            obj_.build(child_)
            self.set_searchPaths(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySources':
            obj_ = factorySourceListType.factory()
            obj_.build(child_)
            self.set_factorySources(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architectures':
            obj_ = architecturesType.factory()
            obj_.build(child_)
            self.set_architectures(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageTemplates':
            obj_ = imageTemplatesType.factory()
            obj_.build(child_)
            self.set_imageTemplates(obj_)
# end class platformType


class nameFlavorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('flavor', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, flavor=None, name=None, valueOf_=''):
        self.flavor = _cast(None, flavor)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nameFlavorType.subclass:
            return nameFlavorType.subclass(*args_, **kwargs_)
        else:
            return nameFlavorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_flavor(self): return self.flavor
    def set_flavor(self, flavor): self.flavor = flavor
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='nameFlavorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='nameFlavorType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='nameFlavorType'):
        outfile.write(' flavor=%s' % (self.format_string(quote_attrib(self.flavor).encode(ExternalEncoding), input_name='flavor'), ))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='nameFlavorType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nameFlavorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.flavor is not None:
            showIndent(outfile, level)
            outfile.write('flavor = %s,\n' % (self.flavor,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('flavor'):
            self.flavor = attrs.get('flavor').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class nameFlavorType


class architecturesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('architecture', 'nameFlavorType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, architecture=None):
        if architecture is None:
            self.architecture = []
        else:
            self.architecture = architecture
    def factory(*args_, **kwargs_):
        if architecturesType.subclass:
            return architecturesType.subclass(*args_, **kwargs_)
        else:
            return architecturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_architecture(self): return self.architecture
    def set_architecture(self, architecture): self.architecture = architecture
    def add_architecture(self, value): self.architecture.append(value)
    def insert_architecture(self, index, value): self.architecture[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='architecturesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='architecturesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='architecturesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='architecturesType'):
        for architecture_ in self.architecture:
            architecture_.export(outfile, level, namespace_, name_='architecture')
    def hasContent_(self):
        if (
            self.architecture
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='architecturesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('architecture=[\n')
        level += 1
        for architecture in self.architecture:
            showIndent(outfile, level)
            outfile.write('model_.architecture(\n')
            architecture.exportLiteral(outfile, level, name_='architecture')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architecture':
            obj_ = nameFlavorType.factory()
            obj_.build(child_)
            self.architecture.append(obj_)
# end class architecturesType


class imageTemplatesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('imageTemplate', 'nameFlavorType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, imageTemplate=None):
        if imageTemplate is None:
            self.imageTemplate = []
        else:
            self.imageTemplate = imageTemplate
    def factory(*args_, **kwargs_):
        if imageTemplatesType.subclass:
            return imageTemplatesType.subclass(*args_, **kwargs_)
        else:
            return imageTemplatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_imageTemplate(self): return self.imageTemplate
    def set_imageTemplate(self, imageTemplate): self.imageTemplate = imageTemplate
    def add_imageTemplate(self, value): self.imageTemplate.append(value)
    def insert_imageTemplate(self, index, value): self.imageTemplate[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='imageTemplatesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='imageTemplatesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='imageTemplatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='imageTemplatesType'):
        for imageTemplate_ in self.imageTemplate:
            imageTemplate_.export(outfile, level, namespace_, name_='imageTemplate')
    def hasContent_(self):
        if (
            self.imageTemplate
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='imageTemplatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('imageTemplate=[\n')
        level += 1
        for imageTemplate in self.imageTemplate:
            showIndent(outfile, level)
            outfile.write('model_.imageTemplate(\n')
            imageTemplate.exportLiteral(outfile, level, name_='imageTemplate')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageTemplate':
            obj_ = nameFlavorType.factory()
            obj_.build(child_)
            self.imageTemplate.append(obj_)
# end class imageTemplatesType


class productDefinition(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('productName', 'xsd:string', 0),
        MemberSpec_('productShortname', 'xsd:string', 0),
        MemberSpec_('productDescription', 'xsd:string', 0),
        MemberSpec_('productVersion', 'xsd:string', 0),
        MemberSpec_('productVersionDescription', 'xsd:string', 0),
        MemberSpec_('conaryRepositoryHostname', 'xsd:string', 0),
        MemberSpec_('conaryNamespace', 'xsd:string', 0),
        MemberSpec_('imageGroup', ['troveSpecType', 'xsd:string'], 0),
        MemberSpec_('baseFlavor', ['flavorStringType', 'xsd:string'], 0),
        MemberSpec_('stages', 'stageListType', 0),
        MemberSpec_('searchPaths', 'searchPathListType', 0),
        MemberSpec_('factorySources', 'factorySourceListType', 0),
        MemberSpec_('architectures', 'architecturesType', 0),
        MemberSpec_('imageTemplates', 'imageTemplatesType', 0),
        MemberSpec_('buildDefinition', 'buildDefinitionType', 0),
        MemberSpec_('platform', 'platformType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, version=None, productName=None, productShortname=None, productDescription=None, productVersion=None, productVersionDescription=None, conaryRepositoryHostname=None, conaryNamespace=None, imageGroup=None, baseFlavor=None, stages=None, searchPaths=None, factorySources=None, architectures=None, imageTemplates=None, buildDefinition=None, platform=None):
        self.version = _cast(None, version)
        self.productName = productName
        self.productShortname = productShortname
        self.productDescription = productDescription
        self.productVersion = productVersion
        self.productVersionDescription = productVersionDescription
        self.conaryRepositoryHostname = conaryRepositoryHostname
        self.conaryNamespace = conaryNamespace
        self.imageGroup = imageGroup
        self.baseFlavor = baseFlavor
        self.stages = stages
        self.searchPaths = searchPaths
        self.factorySources = factorySources
        self.architectures = architectures
        self.imageTemplates = imageTemplates
        self.buildDefinition = buildDefinition
        self.platform = platform
    def factory(*args_, **kwargs_):
        if productDefinition.subclass:
            return productDefinition.subclass(*args_, **kwargs_)
        else:
            return productDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productName(self): return self.productName
    def set_productName(self, productName): self.productName = productName
    def get_productShortname(self): return self.productShortname
    def set_productShortname(self, productShortname): self.productShortname = productShortname
    def get_productDescription(self): return self.productDescription
    def set_productDescription(self, productDescription): self.productDescription = productDescription
    def get_productVersion(self): return self.productVersion
    def set_productVersion(self, productVersion): self.productVersion = productVersion
    def get_productVersionDescription(self): return self.productVersionDescription
    def set_productVersionDescription(self, productVersionDescription): self.productVersionDescription = productVersionDescription
    def get_conaryRepositoryHostname(self): return self.conaryRepositoryHostname
    def set_conaryRepositoryHostname(self, conaryRepositoryHostname): self.conaryRepositoryHostname = conaryRepositoryHostname
    def get_conaryNamespace(self): return self.conaryNamespace
    def set_conaryNamespace(self, conaryNamespace): self.conaryNamespace = conaryNamespace
    def get_imageGroup(self): return self.imageGroup
    def set_imageGroup(self, imageGroup): self.imageGroup = imageGroup
    def validate_imageGroup(self, value):
        # validate type imageGroup
        pass
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def validate_baseFlavor(self, value):
        # validate type baseFlavor
        pass
    def get_stages(self): return self.stages
    def set_stages(self, stages): self.stages = stages
    def get_searchPaths(self): return self.searchPaths
    def set_searchPaths(self, searchPaths): self.searchPaths = searchPaths
    def get_factorySources(self): return self.factorySources
    def set_factorySources(self, factorySources): self.factorySources = factorySources
    def get_architectures(self): return self.architectures
    def set_architectures(self, architectures): self.architectures = architectures
    def get_imageTemplates(self): return self.imageTemplates
    def set_imageTemplates(self, imageTemplates): self.imageTemplates = imageTemplates
    def get_buildDefinition(self): return self.buildDefinition
    def set_buildDefinition(self, buildDefinition): self.buildDefinition = buildDefinition
    def get_platform(self): return self.platform
    def set_platform(self, platform): self.platform = platform
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='rpd:', name_='productDefinition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='productDefinition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='productDefinition'):
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='productDefinition'):
        if self.productName is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductName>%s</%sproductName>\n' % (namespace_, self.format_string(quote_xml(self.productName).encode(ExternalEncoding), input_name='productName'), namespace_))
        if self.productShortname is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductShortname>%s</%sproductShortname>\n' % (namespace_, self.format_string(quote_xml(self.productShortname).encode(ExternalEncoding), input_name='productShortname'), namespace_))
        if self.productDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductDescription>%s</%sproductDescription>\n' % (namespace_, self.format_string(quote_xml(self.productDescription).encode(ExternalEncoding), input_name='productDescription'), namespace_))
        if self.productVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductVersion>%s</%sproductVersion>\n' % (namespace_, self.format_string(quote_xml(self.productVersion).encode(ExternalEncoding), input_name='productVersion'), namespace_))
        if self.productVersionDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductVersionDescription>%s</%sproductVersionDescription>\n' % (namespace_, self.format_string(quote_xml(self.productVersionDescription).encode(ExternalEncoding), input_name='productVersionDescription'), namespace_))
        if self.conaryRepositoryHostname is not None:
            showIndent(outfile, level)
            outfile.write('<%sconaryRepositoryHostname>%s</%sconaryRepositoryHostname>\n' % (namespace_, self.format_string(quote_xml(self.conaryRepositoryHostname).encode(ExternalEncoding), input_name='conaryRepositoryHostname'), namespace_))
        if self.conaryNamespace is not None:
            showIndent(outfile, level)
            outfile.write('<%sconaryNamespace>%s</%sconaryNamespace>\n' % (namespace_, self.format_string(quote_xml(self.conaryNamespace).encode(ExternalEncoding), input_name='conaryNamespace'), namespace_))
        if self.imageGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%simageGroup>%s</%simageGroup>\n' % (namespace_, self.format_string(quote_xml(self.imageGroup).encode(ExternalEncoding), input_name='imageGroup'), namespace_))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseFlavor>%s</%sbaseFlavor>\n' % (namespace_, self.format_string(quote_xml(self.baseFlavor).encode(ExternalEncoding), input_name='baseFlavor'), namespace_))
        if self.stages:
            self.stages.export(outfile, level, namespace_, name_='stages', )
        if self.searchPaths:
            self.searchPaths.export(outfile, level, namespace_, name_='searchPaths')
        if self.factorySources:
            self.factorySources.export(outfile, level, namespace_, name_='factorySources')
        if self.architectures:
            self.architectures.export(outfile, level, namespace_, name_='architectures')
        if self.imageTemplates:
            self.imageTemplates.export(outfile, level, namespace_, name_='imageTemplates')
        if self.buildDefinition:
            self.buildDefinition.export(outfile, level, namespace_, name_='buildDefinition', )
        if self.platform:
            self.platform.export(outfile, level, namespace_, name_='platform')
    def hasContent_(self):
        if (
            self.productName is not None or
            self.productShortname is not None or
            self.productDescription is not None or
            self.productVersion is not None or
            self.productVersionDescription is not None or
            self.conaryRepositoryHostname is not None or
            self.conaryNamespace is not None or
            self.imageGroup is not None or
            self.baseFlavor is not None or
            self.stages is not None or
            self.searchPaths is not None or
            self.factorySources is not None or
            self.architectures is not None or
            self.imageTemplates is not None or
            self.buildDefinition is not None or
            self.platform is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='productDefinition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %s,\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('productName=%s,\n' % quote_python(self.productName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('productShortname=%s,\n' % quote_python(self.productShortname).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('productDescription=%s,\n' % quote_python(self.productDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('productVersion=%s,\n' % quote_python(self.productVersion).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('productVersionDescription=%s,\n' % quote_python(self.productVersionDescription).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('conaryRepositoryHostname=%s,\n' % quote_python(self.conaryRepositoryHostname).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('conaryNamespace=%s,\n' % quote_python(self.conaryNamespace).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('imageGroup=%s,\n' % quote_python(self.imageGroup).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('baseFlavor=%s,\n' % quote_python(self.baseFlavor).encode(ExternalEncoding))
        if self.stages:
            showIndent(outfile, level)
            outfile.write('stages=model_.stageListType(\n')
            self.stages.exportLiteral(outfile, level, name_='stages')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.searchPaths:
            showIndent(outfile, level)
            outfile.write('searchPaths=model_.searchPathListType(\n')
            self.searchPaths.exportLiteral(outfile, level, name_='searchPaths')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.factorySources:
            showIndent(outfile, level)
            outfile.write('factorySources=model_.factorySourceListType(\n')
            self.factorySources.exportLiteral(outfile, level, name_='factorySources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.architectures:
            showIndent(outfile, level)
            outfile.write('architectures=model_.architecturesType(\n')
            self.architectures.exportLiteral(outfile, level, name_='architectures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imageTemplates:
            showIndent(outfile, level)
            outfile.write('imageTemplates=model_.imageTemplatesType(\n')
            self.imageTemplates.exportLiteral(outfile, level, name_='imageTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.buildDefinition:
            showIndent(outfile, level)
            outfile.write('buildDefinition=model_.buildDefinitionType(\n')
            self.buildDefinition.exportLiteral(outfile, level, name_='buildDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.platform:
            showIndent(outfile, level)
            outfile.write('platform=model_.platformType(\n')
            self.platform.exportLiteral(outfile, level, name_='platform')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productName':
            productName_ = ''
            for text__content_ in child_.childNodes:
                productName_ += text__content_.nodeValue
            self.productName = productName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productShortname':
            productShortname_ = ''
            for text__content_ in child_.childNodes:
                productShortname_ += text__content_.nodeValue
            self.productShortname = productShortname_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productDescription':
            productDescription_ = ''
            for text__content_ in child_.childNodes:
                productDescription_ += text__content_.nodeValue
            self.productDescription = productDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productVersion':
            productVersion_ = ''
            for text__content_ in child_.childNodes:
                productVersion_ += text__content_.nodeValue
            self.productVersion = productVersion_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productVersionDescription':
            productVersionDescription_ = ''
            for text__content_ in child_.childNodes:
                productVersionDescription_ += text__content_.nodeValue
            self.productVersionDescription = productVersionDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'conaryRepositoryHostname':
            conaryRepositoryHostname_ = ''
            for text__content_ in child_.childNodes:
                conaryRepositoryHostname_ += text__content_.nodeValue
            self.conaryRepositoryHostname = conaryRepositoryHostname_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'conaryNamespace':
            conaryNamespace_ = ''
            for text__content_ in child_.childNodes:
                conaryNamespace_ += text__content_.nodeValue
            self.conaryNamespace = conaryNamespace_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageGroup':
            imageGroup_ = ''
            for text__content_ in child_.childNodes:
                imageGroup_ += text__content_.nodeValue
            self.imageGroup = imageGroup_
            self.validate_imageGroup(self.imageGroup)    # validate type imageGroup
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseFlavor':
            baseFlavor_ = ''
            for text__content_ in child_.childNodes:
                baseFlavor_ += text__content_.nodeValue
            self.baseFlavor = baseFlavor_
            self.validate_baseFlavor(self.baseFlavor)    # validate type baseFlavor
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stages':
            obj_ = stageListType.factory()
            obj_.build(child_)
            self.set_stages(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPaths':
            obj_ = searchPathListType.factory()
            obj_.build(child_)
            self.set_searchPaths(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySources':
            obj_ = factorySourceListType.factory()
            obj_.build(child_)
            self.set_factorySources(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architectures':
            obj_ = architecturesType.factory()
            obj_.build(child_)
            self.set_architectures(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageTemplates':
            obj_ = imageTemplatesType.factory()
            obj_.build(child_)
            self.set_imageTemplates(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'buildDefinition':
            obj_ = buildDefinitionType.factory()
            obj_.build(child_)
            self.set_buildDefinition(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platform':
            obj_ = platformType.factory()
            obj_.build(child_)
            self.set_platform(obj_)
# end class productDefinition


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = stageType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="stageType", 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = stageType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="stageType",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = stageType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('from supers import *\n\n')
##     sys.stdout.write('rootObj = stageType(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_="stageType")
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

