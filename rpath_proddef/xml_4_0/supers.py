#!/usr/bin/env python

#
# Generated  by generateDS.py.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class stageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('labelSuffix', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('promoteMaps', 'promoteMapsType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, labelSuffix=None, name=None, promoteMaps=None):
        self.labelSuffix = _cast(None, labelSuffix)
        self.name = _cast(None, name)
        self.promoteMaps = promoteMaps
    def factory(*args_, **kwargs_):
        if stageType.subclass:
            return stageType.subclass(*args_, **kwargs_)
        else:
            return stageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_promoteMaps(self): return self.promoteMaps
    def set_promoteMaps(self, promoteMaps): self.promoteMaps = promoteMaps
    def get_labelSuffix(self): return self.labelSuffix
    def set_labelSuffix(self, labelSuffix): self.labelSuffix = labelSuffix
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='rpd:', name_='stageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='stageType'):
        outfile.write(' labelSuffix=%s' % (self.format_string(quote_attrib(self.labelSuffix).encode(ExternalEncoding), input_name='labelSuffix'), ))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='stageType'):
        if self.promoteMaps:
            self.promoteMaps.export(outfile, level, namespace_, name_='promoteMaps')
    def hasContent_(self):
        if (
            self.promoteMaps is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.labelSuffix is not None:
            showIndent(outfile, level)
            outfile.write('labelSuffix = "%s",\n' % (self.labelSuffix,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.promoteMaps is not None:
            showIndent(outfile, level)
            outfile.write('promoteMaps=model_.promoteMapsType(\n')
            self.promoteMaps.exportLiteral(outfile, level, name_='promoteMaps')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('labelSuffix'):
            self.labelSuffix = attrs.get('labelSuffix').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'promoteMaps':
            obj_ = promoteMapsType.factory()
            obj_.build(child_)
            self.set_promoteMaps(obj_)

    def getPromoteMaps(self):
        vals = self.get_promoteMaps()
        if vals is None:
            return []
        return vals.get_promoteMap()
# end class stageType


class stageListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('stage', 'stageType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, stage=None):
        if stage is None:
            self.stage = []
        else:
            self.stage = stage
    def factory(*args_, **kwargs_):
        if stageListType.subclass:
            return stageListType.subclass(*args_, **kwargs_)
        else:
            return stageListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stage(self): return self.stage
    def set_stage(self, stage): self.stage = stage
    def add_stage(self, value): self.stage.append(value)
    def insert_stage(self, index, value): self.stage[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='stageListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stageListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='stageListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='stageListType'):
        for stage_ in self.stage:
            stage_.export(outfile, level, namespace_, name_='stage')
    def hasContent_(self):
        if (
            self.stage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stageListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('stage=[\n')
        level += 1
        for stage_ in self.stage:
            showIndent(outfile, level)
            outfile.write('model_.stageType(\n')
            stage_.exportLiteral(outfile, level, name_='stageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stage':
            obj_ = stageType.factory()
            obj_.build(child_)
            self.stage.append(obj_)
# end class stageListType


class nameLabelType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('troveName', 'xsd:string', 0),
        MemberSpec_('label', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, troveName=None, label=None, valueOf_=''):
        self.troveName = _cast(None, troveName)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nameLabelType.subclass:
            return nameLabelType.subclass(*args_, **kwargs_)
        else:
            return nameLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_troveName(self): return self.troveName
    def set_troveName(self, troveName): self.troveName = troveName
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='nameLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='nameLabelType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='nameLabelType'):
        if self.troveName is not None:
            outfile.write(' troveName=%s' % (self.format_string(quote_attrib(self.troveName).encode(ExternalEncoding), input_name='troveName'), ))
        if self.label is not None:
            outfile.write(' label=%s' % (self.format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='nameLabelType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nameLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.troveName is not None:
            showIndent(outfile, level)
            outfile.write('troveName = "%s",\n' % (self.troveName,))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('troveName'):
            self.troveName = attrs.get('troveName').value
        if attrs.get('label'):
            self.label = attrs.get('label').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    getTroveName = get_troveName
    getLabel = get_label
# end class nameLabelType


class searchPathType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('isPlatformTrove', 'xsd:boolean', 0),
        MemberSpec_('label', 'xsd:string', 0),
        MemberSpec_('troveName', 'xsd:string', 0),
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('isGroupSearchPathTrove', 'xsd:boolean', 0),
        MemberSpec_('isResolveTrove', 'xsd:boolean', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, isPlatformTrove=None, label=None, troveName=None, version=None, isGroupSearchPathTrove=None, isResolveTrove=None, valueOf_=''):
        self.isPlatformTrove = _cast(bool, isPlatformTrove)
        self.label = _cast(None, label)
        self.troveName = _cast(None, troveName)
        self.version = _cast(None, version)
        self.isGroupSearchPathTrove = _cast(bool, isGroupSearchPathTrove)
        self.isResolveTrove = _cast(bool, isResolveTrove)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if searchPathType.subclass:
            return searchPathType.subclass(*args_, **kwargs_)
        else:
            return searchPathType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPlatformTrove(self): return self.isPlatformTrove
    def set_isPlatformTrove(self, isPlatformTrove): self.isPlatformTrove = isPlatformTrove
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_troveName(self): return self.troveName
    def set_troveName(self, troveName): self.troveName = troveName
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isGroupSearchPathTrove(self): return self.isGroupSearchPathTrove
    def set_isGroupSearchPathTrove(self, isGroupSearchPathTrove): self.isGroupSearchPathTrove = isGroupSearchPathTrove
    def get_isResolveTrove(self): return self.isResolveTrove
    def set_isResolveTrove(self, isResolveTrove): self.isResolveTrove = isResolveTrove
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='searchPathType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='searchPathType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='searchPathType'):
        if self.isPlatformTrove is not None:
            outfile.write(' isPlatformTrove="%s"' % self.format_boolean(str_lower(str(self.isPlatformTrove)), input_name='isPlatformTrove'))
        if self.label is not None:
            outfile.write(' label=%s' % (self.format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.troveName is not None:
            outfile.write(' troveName=%s' % (self.format_string(quote_attrib(self.troveName).encode(ExternalEncoding), input_name='troveName'), ))
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isGroupSearchPathTrove is not None:
            outfile.write(' isGroupSearchPathTrove="%s"' % self.format_boolean(str_lower(str(self.isGroupSearchPathTrove)), input_name='isGroupSearchPathTrove'))
        if self.isResolveTrove is not None:
            outfile.write(' isResolveTrove="%s"' % self.format_boolean(str_lower(str(self.isResolveTrove)), input_name='isResolveTrove'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='searchPathType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='searchPathType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.isPlatformTrove is not None:
            showIndent(outfile, level)
            outfile.write('isPlatformTrove = %s,\n' % (self.isPlatformTrove,))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.troveName is not None:
            showIndent(outfile, level)
            outfile.write('troveName = "%s",\n' % (self.troveName,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.isGroupSearchPathTrove is not None:
            showIndent(outfile, level)
            outfile.write('isGroupSearchPathTrove = %s,\n' % (self.isGroupSearchPathTrove,))
        if self.isResolveTrove is not None:
            showIndent(outfile, level)
            outfile.write('isResolveTrove = %s,\n' % (self.isResolveTrove,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('isPlatformTrove'):
            if attrs.get('isPlatformTrove').value in ('true', '1'):
                self.isPlatformTrove = True
            elif attrs.get('isPlatformTrove').value in ('false', '0'):
                self.isPlatformTrove = False
            else:
                raise ValueError('Bad boolean attribute (isPlatformTrove)')
        if attrs.get('label'):
            self.label = attrs.get('label').value
        if attrs.get('troveName'):
            self.troveName = attrs.get('troveName').value
        if attrs.get('version'):
            self.version = attrs.get('version').value
        if attrs.get('isGroupSearchPathTrove'):
            if attrs.get('isGroupSearchPathTrove').value in ('true', '1'):
                self.isGroupSearchPathTrove = True
            elif attrs.get('isGroupSearchPathTrove').value in ('false', '0'):
                self.isGroupSearchPathTrove = False
            else:
                raise ValueError('Bad boolean attribute (isGroupSearchPathTrove)')
        if attrs.get('isResolveTrove'):
            if attrs.get('isResolveTrove').value in ('true', '1'):
                self.isResolveTrove = True
            elif attrs.get('isResolveTrove').value in ('false', '0'):
                self.isResolveTrove = False
            else:
                raise ValueError('Bad boolean attribute (isResolveTrove)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def getTroveTup(self, template=False):
        """
        Get a trovespec tuple for the search path or its template.

        @param template: If C{True}, use the template path; otherwise
            return the "pinned" path.
        @type  template: C{bool}
        @return: (name, version, flavor)
        """
        if template:
            return (self.troveName, self.label, None)
        else:
            version = self.label
            if self.version:
                version += '/' + self.version
            return (self.troveName, version, None)
# end class searchPathType


class searchPathListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('searchPath', 'searchPathType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, searchPath=None):
        if searchPath is None:
            self.searchPath = []
        else:
            self.searchPath = searchPath
    def factory(*args_, **kwargs_):
        if searchPathListType.subclass:
            return searchPathListType.subclass(*args_, **kwargs_)
        else:
            return searchPathListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_searchPath(self): return self.searchPath
    def set_searchPath(self, searchPath): self.searchPath = searchPath
    def add_searchPath(self, value): self.searchPath.append(value)
    def insert_searchPath(self, index, value): self.searchPath[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='searchPathListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='searchPathListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='searchPathListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='searchPathListType'):
        for searchPath_ in self.searchPath:
            searchPath_.export(outfile, level, namespace_, name_='searchPath')
    def hasContent_(self):
        if (
            self.searchPath
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='searchPathListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('searchPath=[\n')
        level += 1
        for searchPath_ in self.searchPath:
            showIndent(outfile, level)
            outfile.write('model_.searchPathType(\n')
            searchPath_.exportLiteral(outfile, level, name_='searchPathType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPath':
            obj_ = searchPathType.factory()
            obj_.build(child_)
            self.searchPath.append(obj_)
# end class searchPathListType


class factorySourceListType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('factorySource', 'searchPathType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, factorySource=None):
        if factorySource is None:
            self.factorySource = []
        else:
            self.factorySource = factorySource
    def factory(*args_, **kwargs_):
        if factorySourceListType.subclass:
            return factorySourceListType.subclass(*args_, **kwargs_)
        else:
            return factorySourceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_factorySource(self): return self.factorySource
    def set_factorySource(self, factorySource): self.factorySource = factorySource
    def add_factorySource(self, value): self.factorySource.append(value)
    def insert_factorySource(self, index, value): self.factorySource[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='factorySourceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='factorySourceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='factorySourceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='factorySourceListType'):
        for factorySource_ in self.factorySource:
            factorySource_.export(outfile, level, namespace_, name_='factorySource')
    def hasContent_(self):
        if (
            self.factorySource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='factorySourceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('factorySource=[\n')
        level += 1
        for factorySource_ in self.factorySource:
            showIndent(outfile, level)
            outfile.write('model_.searchPathType(\n')
            factorySource_.exportLiteral(outfile, level, name_='searchPathType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySource':
            obj_ = searchPathType.factory()
            obj_.build(child_)
            self.factorySource.append(obj_)
# end class factorySourceListType


class autoLoadRecipesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoLoadRecipe', 'nameLabelType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoLoadRecipe=None):
        if autoLoadRecipe is None:
            self.autoLoadRecipe = []
        else:
            self.autoLoadRecipe = autoLoadRecipe
    def factory(*args_, **kwargs_):
        if autoLoadRecipesType.subclass:
            return autoLoadRecipesType.subclass(*args_, **kwargs_)
        else:
            return autoLoadRecipesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoLoadRecipe(self): return self.autoLoadRecipe
    def set_autoLoadRecipe(self, autoLoadRecipe): self.autoLoadRecipe = autoLoadRecipe
    def add_autoLoadRecipe(self, value): self.autoLoadRecipe.append(value)
    def insert_autoLoadRecipe(self, index, value): self.autoLoadRecipe[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='autoLoadRecipesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='autoLoadRecipesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='autoLoadRecipesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='autoLoadRecipesType'):
        for autoLoadRecipe_ in self.autoLoadRecipe:
            autoLoadRecipe_.export(outfile, level, namespace_, name_='autoLoadRecipe')
    def hasContent_(self):
        if (
            self.autoLoadRecipe
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='autoLoadRecipesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('autoLoadRecipe=[\n')
        level += 1
        for autoLoadRecipe_ in self.autoLoadRecipe:
            showIndent(outfile, level)
            outfile.write('model_.nameLabelType(\n')
            autoLoadRecipe_.exportLiteral(outfile, level, name_='nameLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'autoLoadRecipe':
            obj_ = nameLabelType.factory()
            obj_.build(child_)
            self.autoLoadRecipe.append(obj_)
# end class autoLoadRecipesType


class buildDefinitionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('build_', 'buildType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, build_=None):
        if build_ is None:
            self.build_ = []
        else:
            self.build_ = build_
    def factory(*args_, **kwargs_):
        if buildDefinitionType.subclass:
            return buildDefinitionType.subclass(*args_, **kwargs_)
        else:
            return buildDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_build(self): return self.build_
    def set_build(self, build_): self.build_ = build_
    def add_build(self, value): self.build_.append(value)
    def insert_build(self, index, value): self.build_[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='buildDefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='buildDefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='buildDefinitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='buildDefinitionType'):
        for build_ in self.build_:
            build_.export(outfile, level, namespace_, name_='build')
    def hasContent_(self):
        if (
            self.build_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='buildDefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('build_=[\n')
        level += 1
        for build_ in self.build_:
            showIndent(outfile, level)
            outfile.write('model_.buildType(\n')
            build_.exportLiteral(outfile, level, name_='buildType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'build':
            obj_ = buildType.factory()
            obj_.build(child_)
            self.build_.append(obj_)
# end class buildDefinitionType


class imageType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('autoResolve', 'xsd:boolean', 0),
        MemberSpec_('maxIsoSize', 'xsd:positiveInteger', 0),
        MemberSpec_('bugsUrl', 'xsd:string', 0),
        MemberSpec_('natNetworking', 'xsd:boolean', 0),
        MemberSpec_('vhdDiskType', 'xsd:string', 0),
        MemberSpec_('anacondaCustomTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('mediaTemplateTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('baseFileName', 'xsd:string', 0),
        MemberSpec_('vmSnapshots', 'xsd:boolean', 0),
        MemberSpec_('swapSize', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('betaNag', 'xsd:boolean', 0),
        MemberSpec_('buildOVF10', 'xsd:boolean', 0),
        MemberSpec_('anacondaTemplatesTrove', 'rpd:troveSpecType', 0),
        MemberSpec_('vmMemory', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('installLabelPath', 'xsd:string', 0),
        MemberSpec_('unionfs', 'xsd:boolean', 0),
        MemberSpec_('containerFormat', 'xsd:string', 0),
        MemberSpec_('freespace', 'xsd:nonNegativeInteger', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('zisofs', 'xsd:boolean', 0),
        MemberSpec_('diskAdapter', 'xsd:string', 0),
        MemberSpec_('amiHugeDiskMountpoint', 'xsd:string', 0),
        MemberSpec_('showMediaCheck', 'xsd:boolean', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, autoResolve=None, maxIsoSize=None, bugsUrl=None, natNetworking=None, vhdDiskType=None, anacondaCustomTrove=None, mediaTemplateTrove=None, baseFileName=None, vmSnapshots=None, swapSize=None, betaNag=None, buildOVF10=None, anacondaTemplatesTrove=None, vmMemory=None, installLabelPath=None, unionfs=None, containerFormat=None, freespace=None, name=None, zisofs=None, diskAdapter=None, amiHugeDiskMountpoint=None, showMediaCheck=None, valueOf_=''):
        self.autoResolve = _cast(bool, autoResolve)
        self.maxIsoSize = _cast(int, maxIsoSize)
        self.bugsUrl = _cast(None, bugsUrl)
        self.natNetworking = _cast(bool, natNetworking)
        self.vhdDiskType = _cast(None, vhdDiskType)
        self.anacondaCustomTrove = _cast(None, anacondaCustomTrove)
        self.mediaTemplateTrove = _cast(None, mediaTemplateTrove)
        self.baseFileName = _cast(None, baseFileName)
        self.vmSnapshots = _cast(bool, vmSnapshots)
        self.swapSize = _cast(int, swapSize)
        self.betaNag = _cast(bool, betaNag)
        self.buildOVF10 = _cast(bool, buildOVF10)
        self.anacondaTemplatesTrove = _cast(None, anacondaTemplatesTrove)
        self.vmMemory = _cast(int, vmMemory)
        self.installLabelPath = _cast(None, installLabelPath)
        self.unionfs = _cast(bool, unionfs)
        self.containerFormat = _cast(None, containerFormat)
        self.freespace = _cast(int, freespace)
        self.name = _cast(None, name)
        self.zisofs = _cast(bool, zisofs)
        self.diskAdapter = _cast(None, diskAdapter)
        self.amiHugeDiskMountpoint = _cast(None, amiHugeDiskMountpoint)
        self.showMediaCheck = _cast(bool, showMediaCheck)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if imageType.subclass:
            return imageType.subclass(*args_, **kwargs_)
        else:
            return imageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_autoResolve(self): return self.autoResolve
    def set_autoResolve(self, autoResolve): self.autoResolve = autoResolve
    def get_maxIsoSize(self): return self.maxIsoSize
    def set_maxIsoSize(self, maxIsoSize): self.maxIsoSize = maxIsoSize
    def get_bugsUrl(self): return self.bugsUrl
    def set_bugsUrl(self, bugsUrl): self.bugsUrl = bugsUrl
    def get_natNetworking(self): return self.natNetworking
    def set_natNetworking(self, natNetworking): self.natNetworking = natNetworking
    def get_vhdDiskType(self): return self.vhdDiskType
    def set_vhdDiskType(self, vhdDiskType): self.vhdDiskType = vhdDiskType
    def get_anacondaCustomTrove(self): return self.anacondaCustomTrove
    def set_anacondaCustomTrove(self, anacondaCustomTrove): self.anacondaCustomTrove = anacondaCustomTrove
    def get_mediaTemplateTrove(self): return self.mediaTemplateTrove
    def set_mediaTemplateTrove(self, mediaTemplateTrove): self.mediaTemplateTrove = mediaTemplateTrove
    def get_baseFileName(self): return self.baseFileName
    def set_baseFileName(self, baseFileName): self.baseFileName = baseFileName
    def get_vmSnapshots(self): return self.vmSnapshots
    def set_vmSnapshots(self, vmSnapshots): self.vmSnapshots = vmSnapshots
    def get_swapSize(self): return self.swapSize
    def set_swapSize(self, swapSize): self.swapSize = swapSize
    def get_betaNag(self): return self.betaNag
    def set_betaNag(self, betaNag): self.betaNag = betaNag
    def get_buildOVF10(self): return self.buildOVF10
    def set_buildOVF10(self, buildOVF10): self.buildOVF10 = buildOVF10
    def get_anacondaTemplatesTrove(self): return self.anacondaTemplatesTrove
    def set_anacondaTemplatesTrove(self, anacondaTemplatesTrove): self.anacondaTemplatesTrove = anacondaTemplatesTrove
    def get_vmMemory(self): return self.vmMemory
    def set_vmMemory(self, vmMemory): self.vmMemory = vmMemory
    def get_installLabelPath(self): return self.installLabelPath
    def set_installLabelPath(self, installLabelPath): self.installLabelPath = installLabelPath
    def get_unionfs(self): return self.unionfs
    def set_unionfs(self, unionfs): self.unionfs = unionfs
    def get_containerFormat(self): return self.containerFormat
    def set_containerFormat(self, containerFormat): self.containerFormat = containerFormat
    def get_freespace(self): return self.freespace
    def set_freespace(self, freespace): self.freespace = freespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_zisofs(self): return self.zisofs
    def set_zisofs(self, zisofs): self.zisofs = zisofs
    def get_diskAdapter(self): return self.diskAdapter
    def set_diskAdapter(self, diskAdapter): self.diskAdapter = diskAdapter
    def get_amiHugeDiskMountpoint(self): return self.amiHugeDiskMountpoint
    def set_amiHugeDiskMountpoint(self, amiHugeDiskMountpoint): self.amiHugeDiskMountpoint = amiHugeDiskMountpoint
    def get_showMediaCheck(self): return self.showMediaCheck
    def set_showMediaCheck(self, showMediaCheck): self.showMediaCheck = showMediaCheck
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='imageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='imageType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='imageType'):
        if self.autoResolve is not None:
            outfile.write(' autoResolve="%s"' % self.format_boolean(str_lower(str(self.autoResolve)), input_name='autoResolve'))
        if self.maxIsoSize is not None:
            outfile.write(' maxIsoSize="%s"' % self.format_integer(self.maxIsoSize, input_name='maxIsoSize'))
        if self.bugsUrl is not None:
            outfile.write(' bugsUrl=%s' % (self.format_string(quote_attrib(self.bugsUrl).encode(ExternalEncoding), input_name='bugsUrl'), ))
        if self.natNetworking is not None:
            outfile.write(' natNetworking="%s"' % self.format_boolean(str_lower(str(self.natNetworking)), input_name='natNetworking'))
        if self.vhdDiskType is not None:
            outfile.write(' vhdDiskType=%s' % (self.format_string(quote_attrib(self.vhdDiskType).encode(ExternalEncoding), input_name='vhdDiskType'), ))
        if self.anacondaCustomTrove is not None:
            outfile.write(' anacondaCustomTrove=%s' % (quote_attrib(self.anacondaCustomTrove), ))
        if self.mediaTemplateTrove is not None:
            outfile.write(' mediaTemplateTrove=%s' % (quote_attrib(self.mediaTemplateTrove), ))
        if self.baseFileName is not None:
            outfile.write(' baseFileName=%s' % (self.format_string(quote_attrib(self.baseFileName).encode(ExternalEncoding), input_name='baseFileName'), ))
        if self.vmSnapshots is not None:
            outfile.write(' vmSnapshots="%s"' % self.format_boolean(str_lower(str(self.vmSnapshots)), input_name='vmSnapshots'))
        if self.swapSize is not None:
            outfile.write(' swapSize="%s"' % self.format_integer(self.swapSize, input_name='swapSize'))
        if self.betaNag is not None:
            outfile.write(' betaNag="%s"' % self.format_boolean(str_lower(str(self.betaNag)), input_name='betaNag'))
        if self.buildOVF10 is not None:
            outfile.write(' buildOVF10="%s"' % self.format_boolean(str_lower(str(self.buildOVF10)), input_name='buildOVF10'))
        if self.anacondaTemplatesTrove is not None:
            outfile.write(' anacondaTemplatesTrove=%s' % (quote_attrib(self.anacondaTemplatesTrove), ))
        if self.vmMemory is not None:
            outfile.write(' vmMemory="%s"' % self.format_integer(self.vmMemory, input_name='vmMemory'))
        if self.installLabelPath is not None:
            outfile.write(' installLabelPath=%s' % (self.format_string(quote_attrib(self.installLabelPath).encode(ExternalEncoding), input_name='installLabelPath'), ))
        if self.unionfs is not None:
            outfile.write(' unionfs="%s"' % self.format_boolean(str_lower(str(self.unionfs)), input_name='unionfs'))
        if self.containerFormat is not None:
            outfile.write(' containerFormat=%s' % (self.format_string(quote_attrib(self.containerFormat).encode(ExternalEncoding), input_name='containerFormat'), ))
        if self.freespace is not None:
            outfile.write(' freespace="%s"' % self.format_integer(self.freespace, input_name='freespace'))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.zisofs is not None:
            outfile.write(' zisofs="%s"' % self.format_boolean(str_lower(str(self.zisofs)), input_name='zisofs'))
        if self.diskAdapter is not None:
            outfile.write(' diskAdapter=%s' % (self.format_string(quote_attrib(self.diskAdapter).encode(ExternalEncoding), input_name='diskAdapter'), ))
        if self.amiHugeDiskMountpoint is not None:
            outfile.write(' amiHugeDiskMountpoint=%s' % (self.format_string(quote_attrib(self.amiHugeDiskMountpoint).encode(ExternalEncoding), input_name='amiHugeDiskMountpoint'), ))
        if self.showMediaCheck is not None:
            outfile.write(' showMediaCheck="%s"' % self.format_boolean(str_lower(str(self.showMediaCheck)), input_name='showMediaCheck'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='imageType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='imageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.autoResolve is not None:
            showIndent(outfile, level)
            outfile.write('autoResolve = %s,\n' % (self.autoResolve,))
        if self.maxIsoSize is not None:
            showIndent(outfile, level)
            outfile.write('maxIsoSize = %d,\n' % (self.maxIsoSize,))
        if self.bugsUrl is not None:
            showIndent(outfile, level)
            outfile.write('bugsUrl = "%s",\n' % (self.bugsUrl,))
        if self.natNetworking is not None:
            showIndent(outfile, level)
            outfile.write('natNetworking = %s,\n' % (self.natNetworking,))
        if self.vhdDiskType is not None:
            showIndent(outfile, level)
            outfile.write('vhdDiskType = "%s",\n' % (self.vhdDiskType,))
        if self.anacondaCustomTrove is not None:
            showIndent(outfile, level)
            outfile.write('anacondaCustomTrove = %s,\n' % (self.anacondaCustomTrove,))
        if self.mediaTemplateTrove is not None:
            showIndent(outfile, level)
            outfile.write('mediaTemplateTrove = %s,\n' % (self.mediaTemplateTrove,))
        if self.baseFileName is not None:
            showIndent(outfile, level)
            outfile.write('baseFileName = "%s",\n' % (self.baseFileName,))
        if self.vmSnapshots is not None:
            showIndent(outfile, level)
            outfile.write('vmSnapshots = %s,\n' % (self.vmSnapshots,))
        if self.swapSize is not None:
            showIndent(outfile, level)
            outfile.write('swapSize = %d,\n' % (self.swapSize,))
        if self.betaNag is not None:
            showIndent(outfile, level)
            outfile.write('betaNag = %s,\n' % (self.betaNag,))
        if self.buildOVF10 is not None:
            showIndent(outfile, level)
            outfile.write('buildOVF10 = %s,\n' % (self.buildOVF10,))
        if self.anacondaTemplatesTrove is not None:
            showIndent(outfile, level)
            outfile.write('anacondaTemplatesTrove = %s,\n' % (self.anacondaTemplatesTrove,))
        if self.vmMemory is not None:
            showIndent(outfile, level)
            outfile.write('vmMemory = %d,\n' % (self.vmMemory,))
        if self.installLabelPath is not None:
            showIndent(outfile, level)
            outfile.write('installLabelPath = "%s",\n' % (self.installLabelPath,))
        if self.unionfs is not None:
            showIndent(outfile, level)
            outfile.write('unionfs = %s,\n' % (self.unionfs,))
        if self.containerFormat is not None:
            showIndent(outfile, level)
            outfile.write('containerFormat = "%s",\n' % (self.containerFormat,))
        if self.freespace is not None:
            showIndent(outfile, level)
            outfile.write('freespace = %d,\n' % (self.freespace,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.zisofs is not None:
            showIndent(outfile, level)
            outfile.write('zisofs = %s,\n' % (self.zisofs,))
        if self.diskAdapter is not None:
            showIndent(outfile, level)
            outfile.write('diskAdapter = "%s",\n' % (self.diskAdapter,))
        if self.amiHugeDiskMountpoint is not None:
            showIndent(outfile, level)
            outfile.write('amiHugeDiskMountpoint = "%s",\n' % (self.amiHugeDiskMountpoint,))
        if self.showMediaCheck is not None:
            showIndent(outfile, level)
            outfile.write('showMediaCheck = %s,\n' % (self.showMediaCheck,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('autoResolve'):
            if attrs.get('autoResolve').value in ('true', '1'):
                self.autoResolve = True
            elif attrs.get('autoResolve').value in ('false', '0'):
                self.autoResolve = False
            else:
                raise ValueError('Bad boolean attribute (autoResolve)')
        if attrs.get('maxIsoSize'):
            try:
                self.maxIsoSize = int(attrs.get('maxIsoSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (maxIsoSize): %s' % exp)
            if self.maxIsoSize <= 0:
                raise ValueError('Invalid PositiveInteger (maxIsoSize)')
        if attrs.get('bugsUrl'):
            self.bugsUrl = attrs.get('bugsUrl').value
        if attrs.get('natNetworking'):
            if attrs.get('natNetworking').value in ('true', '1'):
                self.natNetworking = True
            elif attrs.get('natNetworking').value in ('false', '0'):
                self.natNetworking = False
            else:
                raise ValueError('Bad boolean attribute (natNetworking)')
        if attrs.get('vhdDiskType'):
            self.vhdDiskType = attrs.get('vhdDiskType').value
        if attrs.get('anacondaCustomTrove'):
            self.anacondaCustomTrove = attrs.get('anacondaCustomTrove').value
        if attrs.get('mediaTemplateTrove'):
            self.mediaTemplateTrove = attrs.get('mediaTemplateTrove').value
        if attrs.get('baseFileName'):
            self.baseFileName = attrs.get('baseFileName').value
        if attrs.get('vmSnapshots'):
            if attrs.get('vmSnapshots').value in ('true', '1'):
                self.vmSnapshots = True
            elif attrs.get('vmSnapshots').value in ('false', '0'):
                self.vmSnapshots = False
            else:
                raise ValueError('Bad boolean attribute (vmSnapshots)')
        if attrs.get('swapSize'):
            try:
                self.swapSize = int(attrs.get('swapSize').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (swapSize): %s' % exp)
            if self.swapSize < 0:
                raise ValueError('Invalid NonNegativeInteger (swapSize)')
        if attrs.get('betaNag'):
            if attrs.get('betaNag').value in ('true', '1'):
                self.betaNag = True
            elif attrs.get('betaNag').value in ('false', '0'):
                self.betaNag = False
            else:
                raise ValueError('Bad boolean attribute (betaNag)')
        if attrs.get('buildOVF10'):
            if attrs.get('buildOVF10').value in ('true', '1'):
                self.buildOVF10 = True
            elif attrs.get('buildOVF10').value in ('false', '0'):
                self.buildOVF10 = False
            else:
                raise ValueError('Bad boolean attribute (buildOVF10)')
        if attrs.get('anacondaTemplatesTrove'):
            self.anacondaTemplatesTrove = attrs.get('anacondaTemplatesTrove').value
        if attrs.get('vmMemory'):
            try:
                self.vmMemory = int(attrs.get('vmMemory').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (vmMemory): %s' % exp)
            if self.vmMemory < 0:
                raise ValueError('Invalid NonNegativeInteger (vmMemory)')
        if attrs.get('installLabelPath'):
            self.installLabelPath = attrs.get('installLabelPath').value
        if attrs.get('unionfs'):
            if attrs.get('unionfs').value in ('true', '1'):
                self.unionfs = True
            elif attrs.get('unionfs').value in ('false', '0'):
                self.unionfs = False
            else:
                raise ValueError('Bad boolean attribute (unionfs)')
        if attrs.get('containerFormat'):
            self.containerFormat = attrs.get('containerFormat').value
        if attrs.get('freespace'):
            try:
                self.freespace = int(attrs.get('freespace').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (freespace): %s' % exp)
            if self.freespace < 0:
                raise ValueError('Invalid NonNegativeInteger (freespace)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('zisofs'):
            if attrs.get('zisofs').value in ('true', '1'):
                self.zisofs = True
            elif attrs.get('zisofs').value in ('false', '0'):
                self.zisofs = False
            else:
                raise ValueError('Bad boolean attribute (zisofs)')
        if attrs.get('diskAdapter'):
            self.diskAdapter = attrs.get('diskAdapter').value
        if attrs.get('amiHugeDiskMountpoint'):
            self.amiHugeDiskMountpoint = attrs.get('amiHugeDiskMountpoint').value
        if attrs.get('showMediaCheck'):
            if attrs.get('showMediaCheck').value in ('true', '1'):
                self.showMediaCheck = True
            elif attrs.get('showMediaCheck').value in ('false', '0'):
                self.showMediaCheck = False
            else:
                raise ValueError('Bad boolean attribute (showMediaCheck)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def getFields(self):
        fieldNames = [ x.get_name()
            for x in self.member_data_items_ ]
        fields = ((x, getattr(self, x)) for x in fieldNames
            if x not in ('containerFormat', 'valueOf_'))
        fields = dict((x, y) for (x, y) in fields if y is not None)
        return fields

    fields = property(getFields)
# end class imageType


class buildType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('containerTemplateRef', 'xsd:string', 0),
        MemberSpec_('architectureRef', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('flavor', 'rpd:flavorStringType', 0),
        MemberSpec_('flavorSetRef', 'xsd:string', 0),
        MemberSpec_('image', 'imageType', 0),
        MemberSpec_('stage', 'stage', 1),
        MemberSpec_('imageGroup', ['troveSpecType', 'xsd:string'], 0),
        MemberSpec_('sourceGroup', ['troveSpecType', 'xsd:string'], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, containerTemplateRef=None, architectureRef=None, name=None, flavor=None, flavorSetRef=None, image=None, stage=None, imageGroup=None, sourceGroup=None):
        self.containerTemplateRef = _cast(None, containerTemplateRef)
        self.architectureRef = _cast(None, architectureRef)
        self.name = _cast(None, name)
        self.flavor = _cast(None, flavor)
        self.flavorSetRef = _cast(None, flavorSetRef)
        self.image = image
        if stage is None:
            self.stage = []
        else:
            self.stage = stage
        self.imageGroup = imageGroup
        self.sourceGroup = sourceGroup
    def factory(*args_, **kwargs_):
        if buildType.subclass:
            return buildType.subclass(*args_, **kwargs_)
        else:
            return buildType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_image(self): return self.image
    def set_image(self, image): self.image = image
    def get_stage(self): return self.stage
    def set_stage(self, stage): self.stage = stage
    def add_stage(self, value): self.stage.append(value)
    def insert_stage(self, index, value): self.stage[index] = value
    def get_imageGroup(self): return self.imageGroup
    def set_imageGroup(self, imageGroup): self.imageGroup = imageGroup
    def validate_imageGroup(self, value):
        # validate type imageGroup
        pass
    def get_sourceGroup(self): return self.sourceGroup
    def set_sourceGroup(self, sourceGroup): self.sourceGroup = sourceGroup
    def validate_sourceGroup(self, value):
        # validate type sourceGroup
        pass
    def get_containerTemplateRef(self): return self.containerTemplateRef
    def set_containerTemplateRef(self, containerTemplateRef): self.containerTemplateRef = containerTemplateRef
    def get_architectureRef(self): return self.architectureRef
    def set_architectureRef(self, architectureRef): self.architectureRef = architectureRef
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_flavor(self): return self.flavor
    def set_flavor(self, flavor): self.flavor = flavor
    def get_flavorSetRef(self): return self.flavorSetRef
    def set_flavorSetRef(self, flavorSetRef): self.flavorSetRef = flavorSetRef
    def export(self, outfile, level, namespace_='rpd:', name_='buildType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='buildType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='buildType'):
        if self.containerTemplateRef is not None:
            outfile.write(' containerTemplateRef=%s' % (self.format_string(quote_attrib(self.containerTemplateRef).encode(ExternalEncoding), input_name='containerTemplateRef'), ))
        if self.architectureRef is not None:
            outfile.write(' architectureRef=%s' % (self.format_string(quote_attrib(self.architectureRef).encode(ExternalEncoding), input_name='architectureRef'), ))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.flavor is not None:
            outfile.write(' flavor=%s' % (quote_attrib(self.flavor), ))
        if self.flavorSetRef is not None:
            outfile.write(' flavorSetRef=%s' % (self.format_string(quote_attrib(self.flavorSetRef).encode(ExternalEncoding), input_name='flavorSetRef'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='buildType'):
        if self.image:
            self.image.export(outfile, level, namespace_, name_='image')
        for stage_ in self.stage:
            stage_.export(outfile, level, namespace_, name_='stage')
        if self.imageGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%simageGroup>%s</%simageGroup>\n' % (namespace_, self.format_string(quote_xml(self.imageGroup).encode(ExternalEncoding), input_name='imageGroup'), namespace_))
        if self.sourceGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%ssourceGroup>%s</%ssourceGroup>\n' % (namespace_, self.format_string(quote_xml(self.sourceGroup).encode(ExternalEncoding), input_name='sourceGroup'), namespace_))
    def hasContent_(self):
        if (
            self.image is not None or
            self.stage or
            self.imageGroup is not None or
            self.sourceGroup is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='buildType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.containerTemplateRef is not None:
            showIndent(outfile, level)
            outfile.write('containerTemplateRef = "%s",\n' % (self.containerTemplateRef,))
        if self.architectureRef is not None:
            showIndent(outfile, level)
            outfile.write('architectureRef = "%s",\n' % (self.architectureRef,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.flavor is not None:
            showIndent(outfile, level)
            outfile.write('flavor = %s,\n' % (self.flavor,))
        if self.flavorSetRef is not None:
            showIndent(outfile, level)
            outfile.write('flavorSetRef = "%s",\n' % (self.flavorSetRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.image is not None:
            showIndent(outfile, level)
            outfile.write('image=model_.imageType(\n')
            self.image.exportLiteral(outfile, level, name_='image')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stage=[\n')
        level += 1
        for stage_ in self.stage:
            showIndent(outfile, level)
            outfile.write('model_.stage(\n')
            stage_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.imageGroup is not None:
            showIndent(outfile, level)
            outfile.write('imageGroup=%s,\n' % quote_python(self.imageGroup).encode(ExternalEncoding))
        if self.sourceGroup is not None:
            showIndent(outfile, level)
            outfile.write('sourceGroup=%s,\n' % quote_python(self.sourceGroup).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('containerTemplateRef'):
            self.containerTemplateRef = attrs.get('containerTemplateRef').value
        if attrs.get('architectureRef'):
            self.architectureRef = attrs.get('architectureRef').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('flavor'):
            self.flavor = attrs.get('flavor').value
        if attrs.get('flavorSetRef'):
            self.flavorSetRef = attrs.get('flavorSetRef').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'image':
            obj_ = imageType.factory()
            obj_.build(child_)
            self.set_image(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stage':
            obj_ = stage.factory()
            obj_.build(child_)
            self.stage.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageGroup':
            imageGroup_ = ''
            for text__content_ in child_.childNodes:
                imageGroup_ += text__content_.nodeValue
            self.imageGroup = imageGroup_
            self.validate_imageGroup(self.imageGroup)    # validate type imageGroup
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sourceGroup':
            sourceGroup_ = ''
            for text__content_ in child_.childNodes:
                sourceGroup_ += text__content_.nodeValue
            self.sourceGroup = sourceGroup_
            self.validate_sourceGroup(self.sourceGroup)    # validate type sourceGroup

    def getBuildStages(self):
        return [ x.get_ref() for x in self.get_stage() ]

    def getBuildImageGroup(self):
        val = self.get_imageGroup()
        if val is None:
            return self.parentImageGroup
        return val

    def getBuildSourceGroup(self):
        val = self.get_sourceGroup()
        if val is None:
            return self.parentSourceGroup
        return val

    def getBuildBaseFlavor(self):
        return self.buildFlavor

    def getBuildImage(self):
        fields = self.containerTemplateFields.copy()
        if self.image:
            fields.update(self.image.getFields())
        return imageType.subclass.factory(**fields)

    getBuildName = get_name
# end class buildType


class stage(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('ref', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, ref=None, valueOf_=''):
        self.ref = _cast(None, ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stage.subclass:
            return stage.subclass(*args_, **kwargs_)
        else:
            return stage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='stage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='stage')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='stage'):
        outfile.write(' ref=%s' % (self.format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='stage'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.ref is not None:
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('ref'):
            self.ref = attrs.get('ref').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class stage


class secondaryLabelsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('secondaryLabel', 'xsd:string', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, secondaryLabel=None):
        if secondaryLabel is None:
            self.secondaryLabel = []
        else:
            self.secondaryLabel = secondaryLabel
    def factory(*args_, **kwargs_):
        if secondaryLabelsType.subclass:
            return secondaryLabelsType.subclass(*args_, **kwargs_)
        else:
            return secondaryLabelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_secondaryLabel(self): return self.secondaryLabel
    def set_secondaryLabel(self, secondaryLabel): self.secondaryLabel = secondaryLabel
    def add_secondaryLabel(self, value): self.secondaryLabel.append(value)
    def insert_secondaryLabel(self, index, value): self.secondaryLabel[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='secondaryLabelsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='secondaryLabelsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='secondaryLabelsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='secondaryLabelsType'):
        for secondaryLabel_ in self.secondaryLabel:
            secondaryLabel_.export(outfile, level, namespace_, name_='secondaryLabel')
    def hasContent_(self):
        if (
            self.secondaryLabel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='secondaryLabelsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('secondaryLabel=[\n')
        level += 1
        for secondaryLabel_ in self.secondaryLabel:
            showIndent(outfile, level)
            outfile.write('model_.secondaryLabel(\n')
            secondaryLabel_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'secondaryLabel':
            obj_ = secondaryLabel.factory()
            obj_.build(child_)
            self.secondaryLabel.append(obj_)
# end class secondaryLabelsType


class secondaryLabel(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('valueOf_', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=''):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if secondaryLabel.subclass:
            return secondaryLabel.subclass(*args_, **kwargs_)
        else:
            return secondaryLabel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='secondaryLabel', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='secondaryLabel')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='secondaryLabel'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='secondaryLabel'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='secondaryLabel'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    getName = get_name
    getLabel = getValueOf_
    setLabel = setValueOf_
    label = property(getLabel, setLabel)
# end class secondaryLabel


class promoteMapsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('promoteMap', 'promoteMapType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, promoteMap=None):
        if promoteMap is None:
            self.promoteMap = []
        else:
            self.promoteMap = promoteMap
    def factory(*args_, **kwargs_):
        if promoteMapsType.subclass:
            return promoteMapsType.subclass(*args_, **kwargs_)
        else:
            return promoteMapsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_promoteMap(self): return self.promoteMap
    def set_promoteMap(self, promoteMap): self.promoteMap = promoteMap
    def add_promoteMap(self, value): self.promoteMap.append(value)
    def insert_promoteMap(self, index, value): self.promoteMap[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='promoteMapsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='promoteMapsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='promoteMapsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='promoteMapsType'):
        for promoteMap_ in self.promoteMap:
            promoteMap_.export(outfile, level, namespace_, name_='promoteMap')
    def hasContent_(self):
        if (
            self.promoteMap
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='promoteMapsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('promoteMap=[\n')
        level += 1
        for promoteMap_ in self.promoteMap:
            showIndent(outfile, level)
            outfile.write('model_.promoteMapType(\n')
            promoteMap_.exportLiteral(outfile, level, name_='promoteMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'promoteMap':
            obj_ = promoteMapType.factory()
            obj_.build(child_)
            self.promoteMap.append(obj_)
# end class promoteMapsType


class promoteMapType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('label', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, name=None, label=None, valueOf_=''):
        self.name = _cast(None, name)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if promoteMapType.subclass:
            return promoteMapType.subclass(*args_, **kwargs_)
        else:
            return promoteMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='promoteMapType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='promoteMapType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='promoteMapType'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' label=%s' % (self.format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='promoteMapType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='promoteMapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('label'):
            self.label = attrs.get('label').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    getMapName = get_name
    getMapLabel = get_label
# end class promoteMapType


class platformDefinitionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('platformName', 'xsd:string', 0),
        MemberSpec_('platformUsageTerms', 'xsd:string', 0),
        MemberSpec_('platformVersionTrove', 'xsd:string', 0),
        MemberSpec_('baseFlavor', ['flavorStringType', 'xsd:string', 'xsd:string'], 0),
        MemberSpec_('contentProvider', 'contentProviderType', 0),
        MemberSpec_('searchPaths', 'searchPathListType', 0),
        MemberSpec_('factorySources', 'factorySourceListType', 0),
        MemberSpec_('autoLoadRecipes', 'autoLoadRecipesType', 0),
        MemberSpec_('secondaryLabels', 'secondaryLabelsType', 0),
        MemberSpec_('architectures', 'architecturesType', 0),
        MemberSpec_('flavorSets', 'flavorSetsType', 0),
        MemberSpec_('containerTemplates', 'containerTemplatesType', 0),
        MemberSpec_('buildTemplates', 'buildTemplatesType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, version=None, platformName=None, platformUsageTerms=None, platformVersionTrove=None, baseFlavor=None, contentProvider=None, searchPaths=None, factorySources=None, autoLoadRecipes=None, secondaryLabels=None, architectures=None, flavorSets=None, containerTemplates=None, buildTemplates=None):
        self.version = _cast(None, version)
        self.platformName = platformName
        self.platformUsageTerms = platformUsageTerms
        self.platformVersionTrove = platformVersionTrove
        self.baseFlavor = baseFlavor
        self.contentProvider = contentProvider
        self.searchPaths = searchPaths
        self.factorySources = factorySources
        self.autoLoadRecipes = autoLoadRecipes
        self.secondaryLabels = secondaryLabels
        self.architectures = architectures
        self.flavorSets = flavorSets
        self.containerTemplates = containerTemplates
        self.buildTemplates = buildTemplates
    def factory(*args_, **kwargs_):
        if platformDefinitionType.subclass:
            return platformDefinitionType.subclass(*args_, **kwargs_)
        else:
            return platformDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platformName(self): return self.platformName
    def set_platformName(self, platformName): self.platformName = platformName
    def get_platformUsageTerms(self): return self.platformUsageTerms
    def set_platformUsageTerms(self, platformUsageTerms): self.platformUsageTerms = platformUsageTerms
    def get_platformVersionTrove(self): return self.platformVersionTrove
    def set_platformVersionTrove(self, platformVersionTrove): self.platformVersionTrove = platformVersionTrove
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def validate_baseFlavor(self, value):
        # validate type baseFlavor
        pass
    def get_contentProvider(self): return self.contentProvider
    def set_contentProvider(self, contentProvider): self.contentProvider = contentProvider
    def get_searchPaths(self): return self.searchPaths
    def set_searchPaths(self, searchPaths): self.searchPaths = searchPaths
    def get_factorySources(self): return self.factorySources
    def set_factorySources(self, factorySources): self.factorySources = factorySources
    def get_autoLoadRecipes(self): return self.autoLoadRecipes
    def set_autoLoadRecipes(self, autoLoadRecipes): self.autoLoadRecipes = autoLoadRecipes
    def get_secondaryLabels(self): return self.secondaryLabels
    def set_secondaryLabels(self, secondaryLabels): self.secondaryLabels = secondaryLabels
    def get_architectures(self): return self.architectures
    def set_architectures(self, architectures): self.architectures = architectures
    def get_flavorSets(self): return self.flavorSets
    def set_flavorSets(self, flavorSets): self.flavorSets = flavorSets
    def get_containerTemplates(self): return self.containerTemplates
    def set_containerTemplates(self, containerTemplates): self.containerTemplates = containerTemplates
    def get_buildTemplates(self): return self.buildTemplates
    def set_buildTemplates(self, buildTemplates): self.buildTemplates = buildTemplates
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='rpd:', name_='platformDefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='platformDefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='platformDefinitionType'):
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='platformDefinitionType'):
        if self.platformName is not None:
            showIndent(outfile, level)
            outfile.write('<%splatformName>%s</%splatformName>\n' % (namespace_, self.format_string(quote_xml(self.platformName).encode(ExternalEncoding), input_name='platformName'), namespace_))
        if self.platformUsageTerms is not None:
            showIndent(outfile, level)
            outfile.write('<%splatformUsageTerms>%s</%splatformUsageTerms>\n' % (namespace_, self.format_string(quote_xml(self.platformUsageTerms).encode(ExternalEncoding), input_name='platformUsageTerms'), namespace_))
        if self.platformVersionTrove is not None:
            showIndent(outfile, level)
            outfile.write('<%splatformVersionTrove>%s</%splatformVersionTrove>\n' % (namespace_, self.format_string(quote_xml(self.platformVersionTrove).encode(ExternalEncoding), input_name='platformVersionTrove'), namespace_))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseFlavor>%s</%sbaseFlavor>\n' % (namespace_, self.format_string(quote_xml(self.baseFlavor).encode(ExternalEncoding), input_name='baseFlavor'), namespace_))
        if self.contentProvider:
            self.contentProvider.export(outfile, level, namespace_, name_='contentProvider')
        if self.searchPaths:
            self.searchPaths.export(outfile, level, namespace_, name_='searchPaths')
        if self.factorySources:
            self.factorySources.export(outfile, level, namespace_, name_='factorySources')
        if self.autoLoadRecipes:
            self.autoLoadRecipes.export(outfile, level, namespace_, name_='autoLoadRecipes')
        if self.secondaryLabels:
            self.secondaryLabels.export(outfile, level, namespace_, name_='secondaryLabels')
        if self.architectures:
            self.architectures.export(outfile, level, namespace_, name_='architectures')
        if self.flavorSets:
            self.flavorSets.export(outfile, level, namespace_, name_='flavorSets')
        if self.containerTemplates:
            self.containerTemplates.export(outfile, level, namespace_, name_='containerTemplates')
        if self.buildTemplates:
            self.buildTemplates.export(outfile, level, namespace_, name_='buildTemplates')
    def hasContent_(self):
        if (
            self.platformName is not None or
            self.platformUsageTerms is not None or
            self.platformVersionTrove is not None or
            self.baseFlavor is not None or
            self.contentProvider is not None or
            self.searchPaths is not None or
            self.factorySources is not None or
            self.autoLoadRecipes is not None or
            self.secondaryLabels is not None or
            self.architectures is not None or
            self.flavorSets is not None or
            self.containerTemplates is not None or
            self.buildTemplates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='platformDefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.platformName is not None:
            showIndent(outfile, level)
            outfile.write('platformName=%s,\n' % quote_python(self.platformName).encode(ExternalEncoding))
        if self.platformUsageTerms is not None:
            showIndent(outfile, level)
            outfile.write('platformUsageTerms=%s,\n' % quote_python(self.platformUsageTerms).encode(ExternalEncoding))
        if self.platformVersionTrove is not None:
            showIndent(outfile, level)
            outfile.write('platformVersionTrove=%s,\n' % quote_python(self.platformVersionTrove).encode(ExternalEncoding))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('baseFlavor=%s,\n' % quote_python(self.baseFlavor).encode(ExternalEncoding))
        if self.contentProvider is not None:
            showIndent(outfile, level)
            outfile.write('contentProvider=model_.contentProviderType(\n')
            self.contentProvider.exportLiteral(outfile, level, name_='contentProvider')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.searchPaths is not None:
            showIndent(outfile, level)
            outfile.write('searchPaths=model_.searchPathListType(\n')
            self.searchPaths.exportLiteral(outfile, level, name_='searchPaths')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.factorySources is not None:
            showIndent(outfile, level)
            outfile.write('factorySources=model_.factorySourceListType(\n')
            self.factorySources.exportLiteral(outfile, level, name_='factorySources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoLoadRecipes is not None:
            showIndent(outfile, level)
            outfile.write('autoLoadRecipes=model_.autoLoadRecipesType(\n')
            self.autoLoadRecipes.exportLiteral(outfile, level, name_='autoLoadRecipes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secondaryLabels is not None:
            showIndent(outfile, level)
            outfile.write('secondaryLabels=model_.secondaryLabelsType(\n')
            self.secondaryLabels.exportLiteral(outfile, level, name_='secondaryLabels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.architectures is not None:
            showIndent(outfile, level)
            outfile.write('architectures=model_.architecturesType(\n')
            self.architectures.exportLiteral(outfile, level, name_='architectures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flavorSets is not None:
            showIndent(outfile, level)
            outfile.write('flavorSets=model_.flavorSetsType(\n')
            self.flavorSets.exportLiteral(outfile, level, name_='flavorSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.containerTemplates is not None:
            showIndent(outfile, level)
            outfile.write('containerTemplates=model_.containerTemplatesType(\n')
            self.containerTemplates.exportLiteral(outfile, level, name_='containerTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.buildTemplates is not None:
            showIndent(outfile, level)
            outfile.write('buildTemplates=model_.buildTemplatesType(\n')
            self.buildTemplates.exportLiteral(outfile, level, name_='buildTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platformName':
            platformName_ = ''
            for text__content_ in child_.childNodes:
                platformName_ += text__content_.nodeValue
            self.platformName = platformName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platformUsageTerms':
            platformUsageTerms_ = ''
            for text__content_ in child_.childNodes:
                platformUsageTerms_ += text__content_.nodeValue
            self.platformUsageTerms = platformUsageTerms_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platformVersionTrove':
            platformVersionTrove_ = ''
            for text__content_ in child_.childNodes:
                platformVersionTrove_ += text__content_.nodeValue
            self.platformVersionTrove = platformVersionTrove_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseFlavor':
            baseFlavor_ = ''
            for text__content_ in child_.childNodes:
                baseFlavor_ += text__content_.nodeValue
            self.baseFlavor = baseFlavor_
            self.validate_baseFlavor(self.baseFlavor)    # validate type baseFlavor
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'contentProvider':
            obj_ = contentProviderType.factory()
            obj_.build(child_)
            self.set_contentProvider(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPaths':
            obj_ = searchPathListType.factory()
            obj_.build(child_)
            self.set_searchPaths(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySources':
            obj_ = factorySourceListType.factory()
            obj_.build(child_)
            self.set_factorySources(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'autoLoadRecipes':
            obj_ = autoLoadRecipesType.factory()
            obj_.build(child_)
            self.set_autoLoadRecipes(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'secondaryLabels':
            obj_ = secondaryLabelsType.factory()
            obj_.build(child_)
            self.set_secondaryLabels(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architectures':
            obj_ = architecturesType.factory()
            obj_.build(child_)
            self.set_architectures(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'flavorSets':
            obj_ = flavorSetsType.factory()
            obj_.build(child_)
            self.set_flavorSets(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'containerTemplates':
            obj_ = containerTemplatesType.factory()
            obj_.build(child_)
            self.set_containerTemplates(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'buildTemplates':
            obj_ = buildTemplatesType.factory()
            obj_.build(child_)
            self.set_buildTemplates(obj_)
# end class platformDefinitionType


class contentProviderType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('description', 'xsd:string', 0),
        MemberSpec_('contentSourceType', 'contentSourceTypeType', 1),
        MemberSpec_('dataSource', 'dataSourceType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, contentSourceType=None, dataSource=None):
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        if contentSourceType is None:
            self.contentSourceType = []
        else:
            self.contentSourceType = contentSourceType
        if dataSource is None:
            self.dataSource = []
        else:
            self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if contentProviderType.subclass:
            return contentProviderType.subclass(*args_, **kwargs_)
        else:
            return contentProviderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contentSourceType(self): return self.contentSourceType
    def set_contentSourceType(self, contentSourceType): self.contentSourceType = contentSourceType
    def add_contentSourceType(self, value): self.contentSourceType.append(value)
    def insert_contentSourceType(self, index, value): self.contentSourceType[index] = value
    def get_dataSource(self): return self.dataSource
    def set_dataSource(self, dataSource): self.dataSource = dataSource
    def add_dataSource(self, value): self.dataSource.append(value)
    def insert_dataSource(self, index, value): self.dataSource[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def export(self, outfile, level, namespace_='rpd:', name_='contentProviderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='contentProviderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='contentProviderType'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' description=%s' % (self.format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='contentProviderType'):
        for contentSourceType_ in self.contentSourceType:
            contentSourceType_.export(outfile, level, namespace_, name_='contentSourceType')
        for dataSource_ in self.dataSource:
            dataSource_.export(outfile, level, namespace_, name_='dataSource')
    def hasContent_(self):
        if (
            self.contentSourceType or
            self.dataSource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contentProviderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contentSourceType=[\n')
        level += 1
        for contentSourceType_ in self.contentSourceType:
            showIndent(outfile, level)
            outfile.write('model_.contentSourceTypeType(\n')
            contentSourceType_.exportLiteral(outfile, level, name_='contentSourceTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dataSource=[\n')
        level += 1
        for dataSource_ in self.dataSource:
            showIndent(outfile, level)
            outfile.write('model_.dataSourceType(\n')
            dataSource_.exportLiteral(outfile, level, name_='dataSourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('description'):
            self.description = attrs.get('description').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'contentSourceType':
            obj_ = contentSourceTypeType.factory()
            obj_.build(child_)
            self.contentSourceType.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataSource':
            obj_ = dataSourceType.factory()
            obj_.build(child_)
            self.dataSource.append(obj_)

    def _getDataSources(self):
        if self.dataSource is None:
            return []
        return self.dataSource
    dataSources = property(_getDataSources)

    def _getContentSourceTypes(self):
        if self.contentSourceType is None:
            return []
        return self.contentSourceType
    contentSourceTypes = property(_getContentSourceTypes)
# end class contentProviderType


class dataSourceType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('description', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, valueOf_=''):
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dataSourceType.subclass:
            return dataSourceType.subclass(*args_, **kwargs_)
        else:
            return dataSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='dataSourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dataSourceType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='dataSourceType'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' description=%s' % (self.format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='dataSourceType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataSourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('description'):
            self.description = attrs.get('description').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class dataSourceType


class contentSourceTypeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('isSingleton', 'xsd:boolean', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('description', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, isSingleton=None, name=None, description=None, valueOf_=''):
        self.isSingleton = _cast(bool, isSingleton)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if contentSourceTypeType.subclass:
            return contentSourceTypeType.subclass(*args_, **kwargs_)
        else:
            return contentSourceTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isSingleton(self): return self.isSingleton
    def set_isSingleton(self, isSingleton): self.isSingleton = isSingleton
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='contentSourceTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='contentSourceTypeType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='contentSourceTypeType'):
        if self.isSingleton is not None:
            outfile.write(' isSingleton="%s"' % self.format_boolean(str_lower(str(self.isSingleton)), input_name='isSingleton'))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' description=%s' % (self.format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='contentSourceTypeType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contentSourceTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.isSingleton is not None:
            showIndent(outfile, level)
            outfile.write('isSingleton = %s,\n' % (self.isSingleton,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('isSingleton'):
            if attrs.get('isSingleton').value in ('true', '1'):
                self.isSingleton = True
            elif attrs.get('isSingleton').value in ('false', '0'):
                self.isSingleton = False
            else:
                raise ValueError('Bad boolean attribute (isSingleton)')
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('description'):
            self.description = attrs.get('description').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class contentSourceTypeType


class platformType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('sourceTrove', 'xsd:string', 0),
        MemberSpec_('useLatest', 'xsd:boolean', 0),
        MemberSpec_('platformName', 'xsd:string', 0),
        MemberSpec_('platformUsageTerms', 'xsd:string', 0),
        MemberSpec_('platformVersionTrove', 'xsd:string', 0),
        MemberSpec_('baseFlavor', ['flavorStringType', 'xsd:string', 'xsd:string'], 0),
        MemberSpec_('contentProvider', 'contentProviderType', 0),
        MemberSpec_('searchPaths', 'searchPathListType', 0),
        MemberSpec_('factorySources', 'factorySourceListType', 0),
        MemberSpec_('autoLoadRecipes', 'autoLoadRecipesType', 0),
        MemberSpec_('secondaryLabels', 'secondaryLabelsType', 0),
        MemberSpec_('architectures', 'architecturesType', 0),
        MemberSpec_('flavorSets', 'flavorSetsType', 0),
        MemberSpec_('containerTemplates', 'containerTemplatesType', 0),
        MemberSpec_('buildTemplates', 'buildTemplatesType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, sourceTrove=None, useLatest=None, platformName=None, platformUsageTerms=None, platformVersionTrove=None, baseFlavor=None, contentProvider=None, searchPaths=None, factorySources=None, autoLoadRecipes=None, secondaryLabels=None, architectures=None, flavorSets=None, containerTemplates=None, buildTemplates=None):
        self.sourceTrove = _cast(None, sourceTrove)
        self.useLatest = _cast(bool, useLatest)
        self.platformName = platformName
        self.platformUsageTerms = platformUsageTerms
        self.platformVersionTrove = platformVersionTrove
        self.baseFlavor = baseFlavor
        self.contentProvider = contentProvider
        self.searchPaths = searchPaths
        self.factorySources = factorySources
        self.autoLoadRecipes = autoLoadRecipes
        self.secondaryLabels = secondaryLabels
        self.architectures = architectures
        self.flavorSets = flavorSets
        self.containerTemplates = containerTemplates
        self.buildTemplates = buildTemplates
    def factory(*args_, **kwargs_):
        if platformType.subclass:
            return platformType.subclass(*args_, **kwargs_)
        else:
            return platformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platformName(self): return self.platformName
    def set_platformName(self, platformName): self.platformName = platformName
    def get_platformUsageTerms(self): return self.platformUsageTerms
    def set_platformUsageTerms(self, platformUsageTerms): self.platformUsageTerms = platformUsageTerms
    def get_platformVersionTrove(self): return self.platformVersionTrove
    def set_platformVersionTrove(self, platformVersionTrove): self.platformVersionTrove = platformVersionTrove
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def validate_baseFlavor(self, value):
        # validate type baseFlavor
        pass
    def get_contentProvider(self): return self.contentProvider
    def set_contentProvider(self, contentProvider): self.contentProvider = contentProvider
    def get_searchPaths(self): return self.searchPaths
    def set_searchPaths(self, searchPaths): self.searchPaths = searchPaths
    def get_factorySources(self): return self.factorySources
    def set_factorySources(self, factorySources): self.factorySources = factorySources
    def get_autoLoadRecipes(self): return self.autoLoadRecipes
    def set_autoLoadRecipes(self, autoLoadRecipes): self.autoLoadRecipes = autoLoadRecipes
    def get_secondaryLabels(self): return self.secondaryLabels
    def set_secondaryLabels(self, secondaryLabels): self.secondaryLabels = secondaryLabels
    def get_architectures(self): return self.architectures
    def set_architectures(self, architectures): self.architectures = architectures
    def get_flavorSets(self): return self.flavorSets
    def set_flavorSets(self, flavorSets): self.flavorSets = flavorSets
    def get_containerTemplates(self): return self.containerTemplates
    def set_containerTemplates(self, containerTemplates): self.containerTemplates = containerTemplates
    def get_buildTemplates(self): return self.buildTemplates
    def set_buildTemplates(self, buildTemplates): self.buildTemplates = buildTemplates
    def get_sourceTrove(self): return self.sourceTrove
    def set_sourceTrove(self, sourceTrove): self.sourceTrove = sourceTrove
    def get_useLatest(self): return self.useLatest
    def set_useLatest(self, useLatest): self.useLatest = useLatest
    def export(self, outfile, level, namespace_='rpd:', name_='platformType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='platformType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='platformType'):
        if self.sourceTrove is not None:
            outfile.write(' sourceTrove=%s' % (self.format_string(quote_attrib(self.sourceTrove).encode(ExternalEncoding), input_name='sourceTrove'), ))
        if self.useLatest is not None:
            outfile.write(' useLatest="%s"' % self.format_boolean(str_lower(str(self.useLatest)), input_name='useLatest'))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='platformType'):
        if self.platformName is not None:
            showIndent(outfile, level)
            outfile.write('<%splatformName>%s</%splatformName>\n' % (namespace_, self.format_string(quote_xml(self.platformName).encode(ExternalEncoding), input_name='platformName'), namespace_))
        if self.platformUsageTerms is not None:
            showIndent(outfile, level)
            outfile.write('<%splatformUsageTerms>%s</%splatformUsageTerms>\n' % (namespace_, self.format_string(quote_xml(self.platformUsageTerms).encode(ExternalEncoding), input_name='platformUsageTerms'), namespace_))
        if self.platformVersionTrove is not None:
            showIndent(outfile, level)
            outfile.write('<%splatformVersionTrove>%s</%splatformVersionTrove>\n' % (namespace_, self.format_string(quote_xml(self.platformVersionTrove).encode(ExternalEncoding), input_name='platformVersionTrove'), namespace_))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseFlavor>%s</%sbaseFlavor>\n' % (namespace_, self.format_string(quote_xml(self.baseFlavor).encode(ExternalEncoding), input_name='baseFlavor'), namespace_))
        if self.contentProvider:
            self.contentProvider.export(outfile, level, namespace_, name_='contentProvider')
        if self.searchPaths:
            self.searchPaths.export(outfile, level, namespace_, name_='searchPaths')
        if self.factorySources:
            self.factorySources.export(outfile, level, namespace_, name_='factorySources')
        if self.autoLoadRecipes:
            self.autoLoadRecipes.export(outfile, level, namespace_, name_='autoLoadRecipes')
        if self.secondaryLabels:
            self.secondaryLabels.export(outfile, level, namespace_, name_='secondaryLabels')
        if self.architectures:
            self.architectures.export(outfile, level, namespace_, name_='architectures')
        if self.flavorSets:
            self.flavorSets.export(outfile, level, namespace_, name_='flavorSets')
        if self.containerTemplates:
            self.containerTemplates.export(outfile, level, namespace_, name_='containerTemplates')
        if self.buildTemplates:
            self.buildTemplates.export(outfile, level, namespace_, name_='buildTemplates')
    def hasContent_(self):
        if (
            self.platformName is not None or
            self.platformUsageTerms is not None or
            self.platformVersionTrove is not None or
            self.baseFlavor is not None or
            self.contentProvider is not None or
            self.searchPaths is not None or
            self.factorySources is not None or
            self.autoLoadRecipes is not None or
            self.secondaryLabels is not None or
            self.architectures is not None or
            self.flavorSets is not None or
            self.containerTemplates is not None or
            self.buildTemplates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='platformType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.sourceTrove is not None:
            showIndent(outfile, level)
            outfile.write('sourceTrove = "%s",\n' % (self.sourceTrove,))
        if self.useLatest is not None:
            showIndent(outfile, level)
            outfile.write('useLatest = %s,\n' % (self.useLatest,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.platformName is not None:
            showIndent(outfile, level)
            outfile.write('platformName=%s,\n' % quote_python(self.platformName).encode(ExternalEncoding))
        if self.platformUsageTerms is not None:
            showIndent(outfile, level)
            outfile.write('platformUsageTerms=%s,\n' % quote_python(self.platformUsageTerms).encode(ExternalEncoding))
        if self.platformVersionTrove is not None:
            showIndent(outfile, level)
            outfile.write('platformVersionTrove=%s,\n' % quote_python(self.platformVersionTrove).encode(ExternalEncoding))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('baseFlavor=%s,\n' % quote_python(self.baseFlavor).encode(ExternalEncoding))
        if self.contentProvider is not None:
            showIndent(outfile, level)
            outfile.write('contentProvider=model_.contentProviderType(\n')
            self.contentProvider.exportLiteral(outfile, level, name_='contentProvider')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.searchPaths is not None:
            showIndent(outfile, level)
            outfile.write('searchPaths=model_.searchPathListType(\n')
            self.searchPaths.exportLiteral(outfile, level, name_='searchPaths')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.factorySources is not None:
            showIndent(outfile, level)
            outfile.write('factorySources=model_.factorySourceListType(\n')
            self.factorySources.exportLiteral(outfile, level, name_='factorySources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoLoadRecipes is not None:
            showIndent(outfile, level)
            outfile.write('autoLoadRecipes=model_.autoLoadRecipesType(\n')
            self.autoLoadRecipes.exportLiteral(outfile, level, name_='autoLoadRecipes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secondaryLabels is not None:
            showIndent(outfile, level)
            outfile.write('secondaryLabels=model_.secondaryLabelsType(\n')
            self.secondaryLabels.exportLiteral(outfile, level, name_='secondaryLabels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.architectures is not None:
            showIndent(outfile, level)
            outfile.write('architectures=model_.architecturesType(\n')
            self.architectures.exportLiteral(outfile, level, name_='architectures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flavorSets is not None:
            showIndent(outfile, level)
            outfile.write('flavorSets=model_.flavorSetsType(\n')
            self.flavorSets.exportLiteral(outfile, level, name_='flavorSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.containerTemplates is not None:
            showIndent(outfile, level)
            outfile.write('containerTemplates=model_.containerTemplatesType(\n')
            self.containerTemplates.exportLiteral(outfile, level, name_='containerTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.buildTemplates is not None:
            showIndent(outfile, level)
            outfile.write('buildTemplates=model_.buildTemplatesType(\n')
            self.buildTemplates.exportLiteral(outfile, level, name_='buildTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('sourceTrove'):
            self.sourceTrove = attrs.get('sourceTrove').value
        if attrs.get('useLatest'):
            if attrs.get('useLatest').value in ('true', '1'):
                self.useLatest = True
            elif attrs.get('useLatest').value in ('false', '0'):
                self.useLatest = False
            else:
                raise ValueError('Bad boolean attribute (useLatest)')
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platformName':
            platformName_ = ''
            for text__content_ in child_.childNodes:
                platformName_ += text__content_.nodeValue
            self.platformName = platformName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platformUsageTerms':
            platformUsageTerms_ = ''
            for text__content_ in child_.childNodes:
                platformUsageTerms_ += text__content_.nodeValue
            self.platformUsageTerms = platformUsageTerms_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platformVersionTrove':
            platformVersionTrove_ = ''
            for text__content_ in child_.childNodes:
                platformVersionTrove_ += text__content_.nodeValue
            self.platformVersionTrove = platformVersionTrove_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseFlavor':
            baseFlavor_ = ''
            for text__content_ in child_.childNodes:
                baseFlavor_ += text__content_.nodeValue
            self.baseFlavor = baseFlavor_
            self.validate_baseFlavor(self.baseFlavor)    # validate type baseFlavor
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'contentProvider':
            obj_ = contentProviderType.factory()
            obj_.build(child_)
            self.set_contentProvider(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPaths':
            obj_ = searchPathListType.factory()
            obj_.build(child_)
            self.set_searchPaths(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySources':
            obj_ = factorySourceListType.factory()
            obj_.build(child_)
            self.set_factorySources(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'autoLoadRecipes':
            obj_ = autoLoadRecipesType.factory()
            obj_.build(child_)
            self.set_autoLoadRecipes(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'secondaryLabels':
            obj_ = secondaryLabelsType.factory()
            obj_.build(child_)
            self.set_secondaryLabels(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architectures':
            obj_ = architecturesType.factory()
            obj_.build(child_)
            self.set_architectures(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'flavorSets':
            obj_ = flavorSetsType.factory()
            obj_.build(child_)
            self.set_flavorSets(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'containerTemplates':
            obj_ = containerTemplatesType.factory()
            obj_.build(child_)
            self.set_containerTemplates(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'buildTemplates':
            obj_ = buildTemplatesType.factory()
            obj_.build(child_)
            self.set_buildTemplates(obj_)
# end class platformType


class nameFlavorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('flavor', 'xsd:string', 0),
        MemberSpec_('displayName', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, flavor=None, displayName=None, name=None, valueOf_=''):
        self.flavor = _cast(None, flavor)
        self.displayName = _cast(None, displayName)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nameFlavorType.subclass:
            return nameFlavorType.subclass(*args_, **kwargs_)
        else:
            return nameFlavorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_flavor(self): return self.flavor
    def set_flavor(self, flavor): self.flavor = flavor
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='nameFlavorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='nameFlavorType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='nameFlavorType'):
        outfile.write(' flavor=%s' % (self.format_string(quote_attrib(self.flavor).encode(ExternalEncoding), input_name='flavor'), ))
        outfile.write(' displayName=%s' % (self.format_string(quote_attrib(self.displayName).encode(ExternalEncoding), input_name='displayName'), ))
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='nameFlavorType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nameFlavorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.flavor is not None:
            showIndent(outfile, level)
            outfile.write('flavor = "%s",\n' % (self.flavor,))
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName = "%s",\n' % (self.displayName,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('flavor'):
            self.flavor = attrs.get('flavor').value
        if attrs.get('displayName'):
            self.displayName = attrs.get('displayName').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class nameFlavorType


class architecturesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('architecture', 'nameFlavorType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, architecture=None):
        if architecture is None:
            self.architecture = []
        else:
            self.architecture = architecture
    def factory(*args_, **kwargs_):
        if architecturesType.subclass:
            return architecturesType.subclass(*args_, **kwargs_)
        else:
            return architecturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_architecture(self): return self.architecture
    def set_architecture(self, architecture): self.architecture = architecture
    def add_architecture(self, value): self.architecture.append(value)
    def insert_architecture(self, index, value): self.architecture[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='architecturesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='architecturesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='architecturesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='architecturesType'):
        for architecture_ in self.architecture:
            architecture_.export(outfile, level, namespace_, name_='architecture')
    def hasContent_(self):
        if (
            self.architecture
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='architecturesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('architecture=[\n')
        level += 1
        for architecture_ in self.architecture:
            showIndent(outfile, level)
            outfile.write('model_.nameFlavorType(\n')
            architecture_.exportLiteral(outfile, level, name_='nameFlavorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architecture':
            obj_ = nameFlavorType.factory()
            obj_.build(child_)
            self.architecture.append(obj_)
# end class architecturesType


class flavorSetsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('flavorSet', 'nameFlavorType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, flavorSet=None):
        if flavorSet is None:
            self.flavorSet = []
        else:
            self.flavorSet = flavorSet
    def factory(*args_, **kwargs_):
        if flavorSetsType.subclass:
            return flavorSetsType.subclass(*args_, **kwargs_)
        else:
            return flavorSetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_flavorSet(self): return self.flavorSet
    def set_flavorSet(self, flavorSet): self.flavorSet = flavorSet
    def add_flavorSet(self, value): self.flavorSet.append(value)
    def insert_flavorSet(self, index, value): self.flavorSet[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='flavorSetsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='flavorSetsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='flavorSetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='flavorSetsType'):
        for flavorSet_ in self.flavorSet:
            flavorSet_.export(outfile, level, namespace_, name_='flavorSet')
    def hasContent_(self):
        if (
            self.flavorSet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='flavorSetsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('flavorSet=[\n')
        level += 1
        for flavorSet_ in self.flavorSet:
            showIndent(outfile, level)
            outfile.write('model_.nameFlavorType(\n')
            flavorSet_.exportLiteral(outfile, level, name_='nameFlavorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'flavorSet':
            obj_ = nameFlavorType.factory()
            obj_.build(child_)
            self.flavorSet.append(obj_)
# end class flavorSetsType


class containerTemplatesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('image', 'imageType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, image=None):
        if image is None:
            self.image = []
        else:
            self.image = image
    def factory(*args_, **kwargs_):
        if containerTemplatesType.subclass:
            return containerTemplatesType.subclass(*args_, **kwargs_)
        else:
            return containerTemplatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_image(self): return self.image
    def set_image(self, image): self.image = image
    def add_image(self, value): self.image.append(value)
    def insert_image(self, index, value): self.image[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='containerTemplatesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='containerTemplatesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='containerTemplatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='containerTemplatesType'):
        for image_ in self.image:
            image_.export(outfile, level, namespace_, name_='image')
    def hasContent_(self):
        if (
            self.image
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='containerTemplatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('image=[\n')
        level += 1
        for image_ in self.image:
            showIndent(outfile, level)
            outfile.write('model_.imageType(\n')
            image_.exportLiteral(outfile, level, name_='imageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'image':
            obj_ = imageType.factory()
            obj_.build(child_)
            self.image.append(obj_)
# end class containerTemplatesType


class buildTemplateType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('containerTemplateRef', 'xsd:string', 0),
        MemberSpec_('architectureRef', 'xsd:string', 0),
        MemberSpec_('displayName', 'xsd:string', 0),
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('flavorSetRef', 'xsd:string', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, containerTemplateRef=None, architectureRef=None, displayName=None, name=None, flavorSetRef=None, valueOf_=''):
        self.containerTemplateRef = _cast(None, containerTemplateRef)
        self.architectureRef = _cast(None, architectureRef)
        self.displayName = _cast(None, displayName)
        self.name = _cast(None, name)
        self.flavorSetRef = _cast(None, flavorSetRef)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if buildTemplateType.subclass:
            return buildTemplateType.subclass(*args_, **kwargs_)
        else:
            return buildTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_containerTemplateRef(self): return self.containerTemplateRef
    def set_containerTemplateRef(self, containerTemplateRef): self.containerTemplateRef = containerTemplateRef
    def get_architectureRef(self): return self.architectureRef
    def set_architectureRef(self, architectureRef): self.architectureRef = architectureRef
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_flavorSetRef(self): return self.flavorSetRef
    def set_flavorSetRef(self, flavorSetRef): self.flavorSetRef = flavorSetRef
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='rpd:', name_='buildTemplateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='buildTemplateType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='buildTemplateType'):
        if self.containerTemplateRef is not None:
            outfile.write(' containerTemplateRef=%s' % (self.format_string(quote_attrib(self.containerTemplateRef).encode(ExternalEncoding), input_name='containerTemplateRef'), ))
        if self.architectureRef is not None:
            outfile.write(' architectureRef=%s' % (self.format_string(quote_attrib(self.architectureRef).encode(ExternalEncoding), input_name='architectureRef'), ))
        if self.displayName is not None:
            outfile.write(' displayName=%s' % (self.format_string(quote_attrib(self.displayName).encode(ExternalEncoding), input_name='displayName'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.flavorSetRef is not None:
            outfile.write(' flavorSetRef=%s' % (self.format_string(quote_attrib(self.flavorSetRef).encode(ExternalEncoding), input_name='flavorSetRef'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='buildTemplateType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='buildTemplateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.containerTemplateRef is not None:
            showIndent(outfile, level)
            outfile.write('containerTemplateRef = "%s",\n' % (self.containerTemplateRef,))
        if self.architectureRef is not None:
            showIndent(outfile, level)
            outfile.write('architectureRef = "%s",\n' % (self.architectureRef,))
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName = "%s",\n' % (self.displayName,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.flavorSetRef is not None:
            showIndent(outfile, level)
            outfile.write('flavorSetRef = "%s",\n' % (self.flavorSetRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('containerTemplateRef'):
            self.containerTemplateRef = attrs.get('containerTemplateRef').value
        if attrs.get('architectureRef'):
            self.architectureRef = attrs.get('architectureRef').value
        if attrs.get('displayName'):
            self.displayName = attrs.get('displayName').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('flavorSetRef'):
            self.flavorSetRef = attrs.get('flavorSetRef').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class buildTemplateType


class buildTemplatesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('buildTemplate', 'buildTemplateType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, buildTemplate=None):
        if buildTemplate is None:
            self.buildTemplate = []
        else:
            self.buildTemplate = buildTemplate
    def factory(*args_, **kwargs_):
        if buildTemplatesType.subclass:
            return buildTemplatesType.subclass(*args_, **kwargs_)
        else:
            return buildTemplatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buildTemplate(self): return self.buildTemplate
    def set_buildTemplate(self, buildTemplate): self.buildTemplate = buildTemplate
    def add_buildTemplate(self, value): self.buildTemplate.append(value)
    def insert_buildTemplate(self, index, value): self.buildTemplate[index] = value
    def export(self, outfile, level, namespace_='rpd:', name_='buildTemplatesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='buildTemplatesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='buildTemplatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='buildTemplatesType'):
        for buildTemplate_ in self.buildTemplate:
            buildTemplate_.export(outfile, level, namespace_, name_='buildTemplate')
    def hasContent_(self):
        if (
            self.buildTemplate
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='buildTemplatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('buildTemplate=[\n')
        level += 1
        for buildTemplate_ in self.buildTemplate:
            showIndent(outfile, level)
            outfile.write('model_.buildTemplateType(\n')
            buildTemplate_.exportLiteral(outfile, level, name_='buildTemplateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'buildTemplate':
            obj_ = buildTemplateType.factory()
            obj_.build(child_)
            self.buildTemplate.append(obj_)
# end class buildTemplatesType


class productDefinition(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('productName', 'xsd:string', 0),
        MemberSpec_('productShortname', 'xsd:string', 0),
        MemberSpec_('productDescription', 'xsd:string', 0),
        MemberSpec_('productVersion', 'xsd:string', 0),
        MemberSpec_('productVersionDescription', 'xsd:string', 0),
        MemberSpec_('conaryRepositoryHostname', 'xsd:string', 0),
        MemberSpec_('conaryNamespace', 'xsd:string', 0),
        MemberSpec_('imageGroup', ['troveSpecType', 'xsd:string'], 0),
        MemberSpec_('sourceGroup', ['troveSpecType', 'xsd:string'], 0),
        MemberSpec_('baseLabel', 'xsd:string', 0),
        MemberSpec_('baseFlavor', ['flavorStringType', 'xsd:string'], 0),
        MemberSpec_('stages', 'stageListType', 0),
        MemberSpec_('searchPaths', 'searchPathListType', 0),
        MemberSpec_('factorySources', 'factorySourceListType', 0),
        MemberSpec_('autoLoadRecipes', 'autoLoadRecipesType', 0),
        MemberSpec_('secondaryLabels', 'secondaryLabelsType', 0),
        MemberSpec_('architectures', 'architecturesType', 0),
        MemberSpec_('flavorSets', 'flavorSetsType', 0),
        MemberSpec_('containerTemplates', 'containerTemplatesType', 0),
        MemberSpec_('buildTemplates', 'buildTemplatesType', 0),
        MemberSpec_('buildDefinition', 'buildDefinitionType', 0),
        MemberSpec_('platform', 'platformType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, version=None, productName=None, productShortname=None, productDescription=None, productVersion=None, productVersionDescription=None, conaryRepositoryHostname=None, conaryNamespace=None, imageGroup=None, sourceGroup=None, baseLabel=None, baseFlavor=None, stages=None, searchPaths=None, factorySources=None, autoLoadRecipes=None, secondaryLabels=None, architectures=None, flavorSets=None, containerTemplates=None, buildTemplates=None, buildDefinition=None, platform=None):
        self.version = _cast(None, version)
        self.productName = productName
        self.productShortname = productShortname
        self.productDescription = productDescription
        self.productVersion = productVersion
        self.productVersionDescription = productVersionDescription
        self.conaryRepositoryHostname = conaryRepositoryHostname
        self.conaryNamespace = conaryNamespace
        self.imageGroup = imageGroup
        self.sourceGroup = sourceGroup
        self.baseLabel = baseLabel
        self.baseFlavor = baseFlavor
        self.stages = stages
        self.searchPaths = searchPaths
        self.factorySources = factorySources
        self.autoLoadRecipes = autoLoadRecipes
        self.secondaryLabels = secondaryLabels
        self.architectures = architectures
        self.flavorSets = flavorSets
        self.containerTemplates = containerTemplates
        self.buildTemplates = buildTemplates
        self.buildDefinition = buildDefinition
        self.platform = platform
    def factory(*args_, **kwargs_):
        if productDefinition.subclass:
            return productDefinition.subclass(*args_, **kwargs_)
        else:
            return productDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_productName(self): return self.productName
    def set_productName(self, productName): self.productName = productName
    def get_productShortname(self): return self.productShortname
    def set_productShortname(self, productShortname): self.productShortname = productShortname
    def get_productDescription(self): return self.productDescription
    def set_productDescription(self, productDescription): self.productDescription = productDescription
    def get_productVersion(self): return self.productVersion
    def set_productVersion(self, productVersion): self.productVersion = productVersion
    def get_productVersionDescription(self): return self.productVersionDescription
    def set_productVersionDescription(self, productVersionDescription): self.productVersionDescription = productVersionDescription
    def get_conaryRepositoryHostname(self): return self.conaryRepositoryHostname
    def set_conaryRepositoryHostname(self, conaryRepositoryHostname): self.conaryRepositoryHostname = conaryRepositoryHostname
    def get_conaryNamespace(self): return self.conaryNamespace
    def set_conaryNamespace(self, conaryNamespace): self.conaryNamespace = conaryNamespace
    def get_imageGroup(self): return self.imageGroup
    def set_imageGroup(self, imageGroup): self.imageGroup = imageGroup
    def validate_imageGroup(self, value):
        # validate type imageGroup
        pass
    def get_sourceGroup(self): return self.sourceGroup
    def set_sourceGroup(self, sourceGroup): self.sourceGroup = sourceGroup
    def validate_sourceGroup(self, value):
        # validate type sourceGroup
        pass
    def get_baseLabel(self): return self.baseLabel
    def set_baseLabel(self, baseLabel): self.baseLabel = baseLabel
    def get_baseFlavor(self): return self.baseFlavor
    def set_baseFlavor(self, baseFlavor): self.baseFlavor = baseFlavor
    def validate_baseFlavor(self, value):
        # validate type baseFlavor
        pass
    def get_stages(self): return self.stages
    def set_stages(self, stages): self.stages = stages
    def get_searchPaths(self): return self.searchPaths
    def set_searchPaths(self, searchPaths): self.searchPaths = searchPaths
    def get_factorySources(self): return self.factorySources
    def set_factorySources(self, factorySources): self.factorySources = factorySources
    def get_autoLoadRecipes(self): return self.autoLoadRecipes
    def set_autoLoadRecipes(self, autoLoadRecipes): self.autoLoadRecipes = autoLoadRecipes
    def get_secondaryLabels(self): return self.secondaryLabels
    def set_secondaryLabels(self, secondaryLabels): self.secondaryLabels = secondaryLabels
    def get_architectures(self): return self.architectures
    def set_architectures(self, architectures): self.architectures = architectures
    def get_flavorSets(self): return self.flavorSets
    def set_flavorSets(self, flavorSets): self.flavorSets = flavorSets
    def get_containerTemplates(self): return self.containerTemplates
    def set_containerTemplates(self, containerTemplates): self.containerTemplates = containerTemplates
    def get_buildTemplates(self): return self.buildTemplates
    def set_buildTemplates(self, buildTemplates): self.buildTemplates = buildTemplates
    def get_buildDefinition(self): return self.buildDefinition
    def set_buildDefinition(self, buildDefinition): self.buildDefinition = buildDefinition
    def get_platform(self): return self.platform
    def set_platform(self, platform): self.platform = platform
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='rpd:', name_='productDefinition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='productDefinition')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='rpd:', name_='productDefinition'):
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='rpd:', name_='productDefinition'):
        if self.productName is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductName>%s</%sproductName>\n' % (namespace_, self.format_string(quote_xml(self.productName).encode(ExternalEncoding), input_name='productName'), namespace_))
        if self.productShortname is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductShortname>%s</%sproductShortname>\n' % (namespace_, self.format_string(quote_xml(self.productShortname).encode(ExternalEncoding), input_name='productShortname'), namespace_))
        if self.productDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductDescription>%s</%sproductDescription>\n' % (namespace_, self.format_string(quote_xml(self.productDescription).encode(ExternalEncoding), input_name='productDescription'), namespace_))
        if self.productVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductVersion>%s</%sproductVersion>\n' % (namespace_, self.format_string(quote_xml(self.productVersion).encode(ExternalEncoding), input_name='productVersion'), namespace_))
        if self.productVersionDescription is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductVersionDescription>%s</%sproductVersionDescription>\n' % (namespace_, self.format_string(quote_xml(self.productVersionDescription).encode(ExternalEncoding), input_name='productVersionDescription'), namespace_))
        if self.conaryRepositoryHostname is not None:
            showIndent(outfile, level)
            outfile.write('<%sconaryRepositoryHostname>%s</%sconaryRepositoryHostname>\n' % (namespace_, self.format_string(quote_xml(self.conaryRepositoryHostname).encode(ExternalEncoding), input_name='conaryRepositoryHostname'), namespace_))
        if self.conaryNamespace is not None:
            showIndent(outfile, level)
            outfile.write('<%sconaryNamespace>%s</%sconaryNamespace>\n' % (namespace_, self.format_string(quote_xml(self.conaryNamespace).encode(ExternalEncoding), input_name='conaryNamespace'), namespace_))
        if self.imageGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%simageGroup>%s</%simageGroup>\n' % (namespace_, self.format_string(quote_xml(self.imageGroup).encode(ExternalEncoding), input_name='imageGroup'), namespace_))
        if self.sourceGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%ssourceGroup>%s</%ssourceGroup>\n' % (namespace_, self.format_string(quote_xml(self.sourceGroup).encode(ExternalEncoding), input_name='sourceGroup'), namespace_))
        if self.baseLabel is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseLabel>%s</%sbaseLabel>\n' % (namespace_, self.format_string(quote_xml(self.baseLabel).encode(ExternalEncoding), input_name='baseLabel'), namespace_))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('<%sbaseFlavor>%s</%sbaseFlavor>\n' % (namespace_, self.format_string(quote_xml(self.baseFlavor).encode(ExternalEncoding), input_name='baseFlavor'), namespace_))
        if self.stages:
            self.stages.export(outfile, level, namespace_, name_='stages', )
        if self.searchPaths:
            self.searchPaths.export(outfile, level, namespace_, name_='searchPaths')
        if self.factorySources:
            self.factorySources.export(outfile, level, namespace_, name_='factorySources')
        if self.autoLoadRecipes:
            self.autoLoadRecipes.export(outfile, level, namespace_, name_='autoLoadRecipes')
        if self.secondaryLabels:
            self.secondaryLabels.export(outfile, level, namespace_, name_='secondaryLabels')
        if self.architectures:
            self.architectures.export(outfile, level, namespace_, name_='architectures')
        if self.flavorSets:
            self.flavorSets.export(outfile, level, namespace_, name_='flavorSets')
        if self.containerTemplates:
            self.containerTemplates.export(outfile, level, namespace_, name_='containerTemplates')
        if self.buildTemplates:
            self.buildTemplates.export(outfile, level, namespace_, name_='buildTemplates')
        if self.buildDefinition:
            self.buildDefinition.export(outfile, level, namespace_, name_='buildDefinition')
        if self.platform:
            self.platform.export(outfile, level, namespace_, name_='platform')
    def hasContent_(self):
        if (
            self.productName is not None or
            self.productShortname is not None or
            self.productDescription is not None or
            self.productVersion is not None or
            self.productVersionDescription is not None or
            self.conaryRepositoryHostname is not None or
            self.conaryNamespace is not None or
            self.imageGroup is not None or
            self.sourceGroup is not None or
            self.baseLabel is not None or
            self.baseFlavor is not None or
            self.stages is not None or
            self.searchPaths is not None or
            self.factorySources is not None or
            self.autoLoadRecipes is not None or
            self.secondaryLabels is not None or
            self.architectures is not None or
            self.flavorSets is not None or
            self.containerTemplates is not None or
            self.buildTemplates is not None or
            self.buildDefinition is not None or
            self.platform is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='productDefinition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.productName is not None:
            showIndent(outfile, level)
            outfile.write('productName=%s,\n' % quote_python(self.productName).encode(ExternalEncoding))
        if self.productShortname is not None:
            showIndent(outfile, level)
            outfile.write('productShortname=%s,\n' % quote_python(self.productShortname).encode(ExternalEncoding))
        if self.productDescription is not None:
            showIndent(outfile, level)
            outfile.write('productDescription=%s,\n' % quote_python(self.productDescription).encode(ExternalEncoding))
        if self.productVersion is not None:
            showIndent(outfile, level)
            outfile.write('productVersion=%s,\n' % quote_python(self.productVersion).encode(ExternalEncoding))
        if self.productVersionDescription is not None:
            showIndent(outfile, level)
            outfile.write('productVersionDescription=%s,\n' % quote_python(self.productVersionDescription).encode(ExternalEncoding))
        if self.conaryRepositoryHostname is not None:
            showIndent(outfile, level)
            outfile.write('conaryRepositoryHostname=%s,\n' % quote_python(self.conaryRepositoryHostname).encode(ExternalEncoding))
        if self.conaryNamespace is not None:
            showIndent(outfile, level)
            outfile.write('conaryNamespace=%s,\n' % quote_python(self.conaryNamespace).encode(ExternalEncoding))
        if self.imageGroup is not None:
            showIndent(outfile, level)
            outfile.write('imageGroup=%s,\n' % quote_python(self.imageGroup).encode(ExternalEncoding))
        if self.sourceGroup is not None:
            showIndent(outfile, level)
            outfile.write('sourceGroup=%s,\n' % quote_python(self.sourceGroup).encode(ExternalEncoding))
        if self.baseLabel is not None:
            showIndent(outfile, level)
            outfile.write('baseLabel=%s,\n' % quote_python(self.baseLabel).encode(ExternalEncoding))
        if self.baseFlavor is not None:
            showIndent(outfile, level)
            outfile.write('baseFlavor=%s,\n' % quote_python(self.baseFlavor).encode(ExternalEncoding))
        if self.stages is not None:
            showIndent(outfile, level)
            outfile.write('stages=model_.stageListType(\n')
            self.stages.exportLiteral(outfile, level, name_='stages')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.searchPaths is not None:
            showIndent(outfile, level)
            outfile.write('searchPaths=model_.searchPathListType(\n')
            self.searchPaths.exportLiteral(outfile, level, name_='searchPaths')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.factorySources is not None:
            showIndent(outfile, level)
            outfile.write('factorySources=model_.factorySourceListType(\n')
            self.factorySources.exportLiteral(outfile, level, name_='factorySources')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.autoLoadRecipes is not None:
            showIndent(outfile, level)
            outfile.write('autoLoadRecipes=model_.autoLoadRecipesType(\n')
            self.autoLoadRecipes.exportLiteral(outfile, level, name_='autoLoadRecipes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secondaryLabels is not None:
            showIndent(outfile, level)
            outfile.write('secondaryLabels=model_.secondaryLabelsType(\n')
            self.secondaryLabels.exportLiteral(outfile, level, name_='secondaryLabels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.architectures is not None:
            showIndent(outfile, level)
            outfile.write('architectures=model_.architecturesType(\n')
            self.architectures.exportLiteral(outfile, level, name_='architectures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flavorSets is not None:
            showIndent(outfile, level)
            outfile.write('flavorSets=model_.flavorSetsType(\n')
            self.flavorSets.exportLiteral(outfile, level, name_='flavorSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.containerTemplates is not None:
            showIndent(outfile, level)
            outfile.write('containerTemplates=model_.containerTemplatesType(\n')
            self.containerTemplates.exportLiteral(outfile, level, name_='containerTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.buildTemplates is not None:
            showIndent(outfile, level)
            outfile.write('buildTemplates=model_.buildTemplatesType(\n')
            self.buildTemplates.exportLiteral(outfile, level, name_='buildTemplates')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.buildDefinition is not None:
            showIndent(outfile, level)
            outfile.write('buildDefinition=model_.buildDefinitionType(\n')
            self.buildDefinition.exportLiteral(outfile, level, name_='buildDefinition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.platform is not None:
            showIndent(outfile, level)
            outfile.write('platform=model_.platformType(\n')
            self.platform.exportLiteral(outfile, level, name_='platform')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productName':
            productName_ = ''
            for text__content_ in child_.childNodes:
                productName_ += text__content_.nodeValue
            self.productName = productName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productShortname':
            productShortname_ = ''
            for text__content_ in child_.childNodes:
                productShortname_ += text__content_.nodeValue
            self.productShortname = productShortname_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productDescription':
            productDescription_ = ''
            for text__content_ in child_.childNodes:
                productDescription_ += text__content_.nodeValue
            self.productDescription = productDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productVersion':
            productVersion_ = ''
            for text__content_ in child_.childNodes:
                productVersion_ += text__content_.nodeValue
            self.productVersion = productVersion_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productVersionDescription':
            productVersionDescription_ = ''
            for text__content_ in child_.childNodes:
                productVersionDescription_ += text__content_.nodeValue
            self.productVersionDescription = productVersionDescription_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'conaryRepositoryHostname':
            conaryRepositoryHostname_ = ''
            for text__content_ in child_.childNodes:
                conaryRepositoryHostname_ += text__content_.nodeValue
            self.conaryRepositoryHostname = conaryRepositoryHostname_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'conaryNamespace':
            conaryNamespace_ = ''
            for text__content_ in child_.childNodes:
                conaryNamespace_ += text__content_.nodeValue
            self.conaryNamespace = conaryNamespace_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageGroup':
            imageGroup_ = ''
            for text__content_ in child_.childNodes:
                imageGroup_ += text__content_.nodeValue
            self.imageGroup = imageGroup_
            self.validate_imageGroup(self.imageGroup)    # validate type imageGroup
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sourceGroup':
            sourceGroup_ = ''
            for text__content_ in child_.childNodes:
                sourceGroup_ += text__content_.nodeValue
            self.sourceGroup = sourceGroup_
            self.validate_sourceGroup(self.sourceGroup)    # validate type sourceGroup
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseLabel':
            baseLabel_ = ''
            for text__content_ in child_.childNodes:
                baseLabel_ += text__content_.nodeValue
            self.baseLabel = baseLabel_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'baseFlavor':
            baseFlavor_ = ''
            for text__content_ in child_.childNodes:
                baseFlavor_ += text__content_.nodeValue
            self.baseFlavor = baseFlavor_
            self.validate_baseFlavor(self.baseFlavor)    # validate type baseFlavor
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stages':
            obj_ = stageListType.factory()
            obj_.build(child_)
            self.set_stages(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'searchPaths':
            obj_ = searchPathListType.factory()
            obj_.build(child_)
            self.set_searchPaths(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'factorySources':
            obj_ = factorySourceListType.factory()
            obj_.build(child_)
            self.set_factorySources(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'autoLoadRecipes':
            obj_ = autoLoadRecipesType.factory()
            obj_.build(child_)
            self.set_autoLoadRecipes(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'secondaryLabels':
            obj_ = secondaryLabelsType.factory()
            obj_.build(child_)
            self.set_secondaryLabels(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'architectures':
            obj_ = architecturesType.factory()
            obj_.build(child_)
            self.set_architectures(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'flavorSets':
            obj_ = flavorSetsType.factory()
            obj_.build(child_)
            self.set_flavorSets(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'containerTemplates':
            obj_ = containerTemplatesType.factory()
            obj_.build(child_)
            self.set_containerTemplates(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'buildTemplates':
            obj_ = buildTemplatesType.factory()
            obj_.build(child_)
            self.set_buildTemplates(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'buildDefinition':
            obj_ = buildDefinitionType.factory()
            obj_.build(child_)
            self.set_buildDefinition(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'platform':
            obj_ = platformType.factory()
            obj_.build(child_)
            self.set_platform(obj_)
# end class productDefinition


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = stageType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="stageType", 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = stageType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="stageType",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = stageType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from supers import *\n\n')
##     sys.stdout.write('import supers as model_\n\n')
##     sys.stdout.write('rootObj = model_.stageType(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_="stageType")
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

